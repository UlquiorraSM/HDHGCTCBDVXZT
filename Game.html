<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PokeWilds Clone Prototype</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', Courier, monospace; }
        canvas { display: block; }
        #debug {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0,0,0,0.5);
            padding: 8px;
            pointer-events: none;
            display: none; /* Standardmäßig aus im Menü */
        }
        
        /* Menü Styling */
        .menu-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: linear-gradient(to bottom, #2c3e50, #000000);
            color: white;
            z-index: 100;
        }

        .menu-title {
            font-size: 64px;
            margin-bottom: 50px;
            text-shadow: 4px 4px 0px #000;
            color: #f1c40f;
        }

        .menu-btn {
            background: #34495e;
            color: white;
            border: 2px solid #7f8c8d;
            padding: 15px 40px;
            font-size: 24px;
            margin: 10px;
            cursor: pointer;
            width: 300px;
            font-family: inherit;
            transition: all 0.2s;
            text-transform: uppercase;
        }

        .menu-btn:hover {
            background: #e67e22;
            border-color: #f39c12;
            transform: scale(1.05);
        }

        .hidden { display: none !important; }

        #bottom-bar { 
            position: absolute; 
            left: 0; 
            right: 0; 
            bottom: 0; 
            height: 200px; 
            background: rgba(0,0,0,0.5); 
            color: #fff; 
            z-index: 900; 
            display: none; 
            flex-direction: column; 
            pointer-events: none; /* Klicks gehen durch das leere Panel */
        }
        #bottom-tabs { 
            display: flex; 
            justify-content: center;
            gap: 0; 
            padding: 0; 
            margin-top: auto;
            pointer-events: auto; /* Aber nicht durch die Tabs */
        }
        .tab-btn { 
             padding: 4px 10px; 
             background: rgba(42, 50, 60, 0.95); 
             border: 1px solid rgba(255,255,255,0.15); 
             border-bottom: none;
             cursor: pointer; 
             color: #d2d2d2; 
             font-family: inherit; 
             font-size: 12px;
             min-width: 70px;
             transition: all 0.1s;
             outline: none;
             text-transform: none;
             margin-right: -1px; /* Overlap borders */
         }
         .tab-btn:hover {
             background: rgba(65, 75, 85, 1.0);
             color: #fff;
             z-index: 2;
         }
         .tab-btn.active { 
             background: rgba(85, 95, 105, 1.0); 
             border-color: rgba(255,255,255,0.4);
             color: #fff;
             z-index: 3;
             box-shadow: inset 0 2px 0 rgba(255,255,255,0.3);
         }
         #tab-content { 
             flex: 1; 
             display: flex; 
             padding: 10px; 
             overflow: hidden; 
             background: rgba(30, 35, 40, 0.95);
             border: 1px solid rgba(255,255,255,0.2);
             margin: 0 50px; /* Wider margins for that floating panel look */
             pointer-events: auto;
             box-shadow: 0 -5px 15px rgba(0,0,0,0.5);
         }
        #inventory-panel { width: 100%; display: grid; grid-template-columns: repeat(10, 1fr); grid-auto-rows: 1fr; gap: 6px; padding: 6px; }
        .inv-slot { background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.15); display: flex; align-items: center; justify-content: center; position: relative; }
        .inv-slot img { image-rendering: pixelated; width: 32px; height: 32px; }
        .inv-count { position: absolute; right: 4px; bottom: 2px; font-size: 12px; background: rgba(0,0,0,0.6); padding: 1px 4px; border-radius: 4px; }
        #bottom-bar.collapsed { height: 44px; }
        #bottom-bar.collapsed #tab-content { display: none; }
        #bottom-bar.expanded { height: 200px; }

        /* Formular Styling */
        .form-group {
            margin: 20px 0;
            text-align: left;
            width: 400px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-size: 18px;
            color: #bdc3c7;
        }

        input, select {
            width: 100%;
            padding: 12px;
            font-size: 18px;
            background: #ecf0f1;
            border: none;
            font-family: inherit;
        }
        
        .back-btn {
            margin-top: 30px;
            background: #c0392b;
        }
        .back-btn:hover {
            background: #e74c3c;
        }

        /* Chat / Dialog Styling */
        #chat-overlay {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 600px;
            background: rgba(0, 0, 0, 0.85);
            border: 2px solid #fff;
            border-radius: 10px;
            padding: 15px;
            display: none;
            flex-direction: column;
            gap: 10px;
            color: white;
            z-index: 1000;
        }

        #chat-history {
            height: 150px;
            overflow-y: auto;
            border-bottom: 1px solid #555;
            margin-bottom: 10px;
            padding-right: 5px;
            font-size: 16px;
            line-height: 1.4;
        }
        
        #chat-history .message {
            margin-bottom: 8px;
        }
        
        #chat-history .npc-name {
            color: #f1c40f;
            font-weight: bold;
        }
        
        #chat-history .player-name {
            color: #3498db;
            font-weight: bold;
        }

        #chat-input-container {
            display: flex;
            gap: 10px;
        }

        #chat-input {
            flex-grow: 1;
            background: #2c3e50;
            color: white;
            border: 1px solid #7f8c8d;
            padding: 8px;
            border-radius: 4px;
        }

        #chat-close-btn {
            background: #c0392b;
            border: none;
            color: white;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
        }

        /* Kontextmenü Styling */
        #context-menu {
            position: fixed;
            background: #2c3e50;
            border: 1px solid #7f8c8d;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.5);
            z-index: 2000;
            display: none;
            min-width: 100px;
        }

        .context-menu-item {
            padding: 8px 15px;
            cursor: pointer;
            color: white;
            font-size: 14px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .context-menu-item:last-child {
            border-bottom: none;
        }

        .context-menu-item:hover {
             background: #3498db;
         }

         /* In-Game Action Menu (RimWorld style) */
         #action-menu {
             position: absolute;
             display: none;
             flex-direction: column;
             gap: 4px;
             z-index: 1100;
             pointer-events: auto;
         }

         .action-btn {
             background: rgba(42, 50, 60, 0.95);
             border: 1px solid rgba(255,255,255,0.3);
             color: white;
             padding: 4px 12px;
             font-size: 14px;
             cursor: pointer;
             font-family: inherit;
             text-align: center;
             min-width: 80px;
             transition: all 0.1s;
             box-shadow: 2px 2px 5px rgba(0,0,0,0.5);
         }

         .action-btn:hover {
             background: rgba(65, 75, 85, 1.0);
             border-color: rgba(255,255,255,0.6);
             transform: scale(1.05);
         }

         .action-btn:active {
             background: rgba(85, 95, 105, 1.0);
             transform: scale(0.95);
         }

     </style>
 </head>
 <body>
     <div id="debug">Debug Info...</div>

     <!-- In-Game Aktionsmenü -->
     <div id="action-menu"></div>

     <!-- Kontextmenü -->
     <div id="context-menu"></div>

    <!-- Chat Overlay -->
    <div id="chat-overlay">
        <div id="chat-header" style="color: #aaa; font-size: 12px; margin-bottom: 5px;">Talking to...</div>
        <div id="chat-history"></div>
        <div id="chat-input-container">
            <input type="text" id="chat-input" placeholder="Type your message... (Enter to send)" autocomplete="off">
            <button id="chat-close-btn">Close</button>
        </div>
    </div>

    <div id="bottom-bar" class="collapsed">
        <div id="tab-content">
            <div id="inventory-panel"></div>
        </div>
        <div id="bottom-tabs">
            <button class="tab-btn" data-tab="work">Work</button>
            <button class="tab-btn" data-tab="schedule">Schedule</button>
            <button class="tab-btn" data-tab="assign">Assign</button>
            <button class="tab-btn" data-tab="animals">Animals</button>
            <button class="tab-btn" data-tab="build">Build</button>
            <button class="tab-btn" data-tab="quest">Quest</button>
            <button class="tab-btn" data-tab="world">World</button>
            <button class="tab-btn" data-tab="history">History</button>
            <button class="tab-btn" data-tab="factions">Factions</button>
            <button class="tab-btn" data-tab="inventory">Inventory</button>
            <button class="tab-btn" data-tab="menu">Menu</button>
        </div>
    </div>

    <!-- Hauptmenü -->
    <div id="main-menu" class="menu-screen">
        <h1 class="menu-title">WebMon</h1>
        <button class="menu-btn" id="btn-play">Play World</button>
        <button class="menu-btn" id="btn-load">Load World</button>
        <button class="menu-btn" id="btn-settings">Settings</button>
    </div>

    <!-- Neue Welt Screen -->
    <div id="new-world-screen" class="menu-screen hidden">
        <h1 class="menu-title">Create New World</h1>
        
        <div class="form-group">
            <label>World Name:</label>
            <input type="text" id="world-name" placeholder="My New World" value="New World">
        </div>

        <div class="form-group">
            <label>World Size:</label>
            <select id="world-size">
                <option value="500">Dwarfism - 500x500</option>
                <option value="750">Short - 750x750</option>
                <option value="1000" selected>Normal - 1000x1000</option>
                <option value="1250">Big - 1250x1250</option>
                <option value="1500">Giant - 1500x1500</option>
            </select>
        </div>

        <button class="menu-btn" id="btn-start-game">Start Adventure</button>
        <button class="menu-btn back-btn" id="btn-back-main">Back</button>
    </div>

    <script>
        (function() {
            // --- UI Elemente ---
            const mainMenu = document.getElementById('main-menu');
            const newWorldScreen = document.getElementById('new-world-screen');
            const debugEl = document.getElementById('debug');
            
            // --- Event Listener Menü ---
            const chatOverlay = document.getElementById('chat-overlay');
            const chatHistory = document.getElementById('chat-history');
            const chatInput = document.getElementById('chat-input');
            const chatCloseBtn = document.getElementById('chat-close-btn');
            const chatHeader = document.getElementById('chat-header');
            let currentChatPartner = null;
            const bottomBar = document.getElementById('bottom-bar');
            const inventoryPanel = document.getElementById('inventory-panel');
            let currentOpenTab = null;

            document.getElementById('btn-play').addEventListener('click', () => {
                mainMenu.classList.add('hidden');
                newWorldScreen.classList.remove('hidden');
            });

            document.getElementById('btn-back-main').addEventListener('click', () => {
                newWorldScreen.classList.add('hidden');
                mainMenu.classList.remove('hidden');
            });

            document.getElementById('btn-start-game').addEventListener('click', () => {
                const size = parseInt(document.getElementById('world-size').value);
                const name = document.getElementById('world-name').value;
                startGame(size, name);
            });
            
            // Chat Events
            chatCloseBtn.addEventListener('click', () => {
                closeChat();
            });

            document.body.addEventListener('click', (e) => {
                const btn = e.target.closest('.tab-btn');
                if (!btn) return;
                const tab = btn.getAttribute('data-tab');

                if (currentOpenTab === tab) {
                    // Toggle schließen
                    currentOpenTab = null;
                    bottomBar.classList.remove('expanded');
                    bottomBar.classList.add('collapsed');
                    [...document.querySelectorAll('.tab-btn')].forEach(b => b.classList.remove('active'));
                    return;
                }

                currentOpenTab = tab;
                bottomBar.classList.remove('collapsed');
                bottomBar.classList.add('expanded');
                [...document.querySelectorAll('.tab-btn')].forEach(b => b.classList.remove('active'));
                btn.classList.add('active');

                renderTabContent(tab);
            });

            let inventory = [];
            let currentBuildId = null; // Aktuell ausgewähltes Gebäude zum Bauen

            function renderTabContent(tab) {
                const content = document.getElementById('tab-content');
                content.innerHTML = ''; // Clear

                if (tab === 'inventory') {
                    const invPanel = document.createElement('div');
                    invPanel.id = 'inventory-panel';
                    content.appendChild(invPanel);
                    renderInventory();
                } else if (tab === 'build') {
                    renderBuildTab(content);
                } else {
                    const placeholder = document.createElement('div');
                    placeholder.style.padding = '20px';
                    placeholder.style.color = '#aaa';
                    placeholder.style.fontSize = '18px';
                    placeholder.style.textAlign = 'center';
                    placeholder.style.width = '100%';
                    placeholder.innerHTML = `This is the <strong>${tab.charAt(0).toUpperCase() + tab.slice(1)}</strong> tab.<br><span style="font-size: 14px;">Placeholder content for future features.</span>`;
                    content.appendChild(placeholder);
                }
            }

            function renderBuildTab(container) {
                const buildPanel = document.createElement('div');
                buildPanel.id = 'build-panel';
                buildPanel.style.display = 'flex';
                buildPanel.style.gap = '15px';
                buildPanel.style.padding = '15px';
                buildPanel.style.flexWrap = 'wrap';

                for (const key in BUILDINGS) {
                    const b = BUILDINGS[key];
                    const item = document.createElement('div');
                    item.className = 'build-item';
                    item.style.background = 'rgba(42, 50, 60, 0.9)';
                    item.style.border = '1px solid rgba(255,255,255,0.2)';
                    item.style.padding = '10px';
                    item.style.width = '100px';
                    item.style.textAlign = 'center';
                    item.style.cursor = 'pointer';
                    item.style.borderRadius = '4px';
                    
                    const img = document.createElement('img');
                    img.src = b.obj.imageSrc;
                    img.style.width = '48px';
                    img.style.height = '48px';
                    img.style.marginBottom = '5px';
                    
                    const name = document.createElement('div');
                    name.innerText = b.name;
                    name.style.fontSize = '13px';
                    name.style.fontWeight = 'bold';
                    
                    const cost = document.createElement('div');
                    const costEntries = Object.entries(b.cost).map(([id, count]) => `${count}x ${id}`);
                    cost.innerText = costEntries.join(', ');
                    cost.style.fontSize = '10px';
                    cost.style.color = '#aaa';
                    
                    item.appendChild(img);
                    item.appendChild(name);
                    item.appendChild(cost);
                    
                    item.onclick = () => {
                        if (canAfford(b.cost)) {
                            currentBuildId = b.id;
                            console.log(`Building ${b.name} selected. Click on map to place.`);
                            // Panel schließen für bessere Sicht beim Platzieren
                            currentOpenTab = null;
                            bottomBar.classList.remove('expanded');
                            bottomBar.classList.add('collapsed');
                            [...document.querySelectorAll('.tab-btn')].forEach(btn => btn.classList.remove('active'));
                        } else {
                            alert("Not enough resources!");
                        }
                    };
                    
                    buildPanel.appendChild(item);
                }
                container.appendChild(buildPanel);
            }

            function canAfford(cost) {
                for (const [id, count] of Object.entries(cost)) {
                    const slot = player.inventory.find(s => s.id === id);
                    if (!slot || slot.count < count) return false;
                }
                return true;
            }

            function consumeResources(cost) {
                for (const [id, count] of Object.entries(cost)) {
                    const slot = player.inventory.find(s => s.id === id);
                    slot.count -= count;
                    if (slot.count <= 0) {
                        player.inventory = player.inventory.filter(s => s.id !== id);
                    }
                }
                renderInventory();
            }

            chatInput.addEventListener('keydown', async (e) => {
                if (e.key === 'Enter' && chatInput.value.trim() !== '') {
                    const message = chatInput.value.trim();
                    chatInput.value = '';
                    
                    // Player Message
                    addChatMessage("Player", message, "player-name");
                    
                    // AI Response
                    if (currentChatPartner && currentChatPartner.npc) {
                        try {
                            const response = await generateAIResponse(currentChatPartner, message);
                            // Check again if still talking to same partner after async wait
                            if (currentChatPartner && currentChatPartner.npc) {
                                addChatMessage(currentChatPartner.npc.name, response, "npc-name");
                            }
                        } catch (err) {
                            console.error("Error generating response:", err);
                            addChatMessage("System", "Error generating response.", "npc-name");
                        }
                    }
                }
            });

            function addChatMessage(sender, text, cssClass) {
                const div = document.createElement('div');
                div.className = 'message';
                div.innerHTML = `<span class="${cssClass}">${sender}:</span> ${text}`;
                chatHistory.appendChild(div);
                chatHistory.scrollTop = chatHistory.scrollHeight;
            }

            function openChat(entity) {
                if (!entity || !entity.npc) return; // Safety check
                
                currentChatPartner = entity;
                chatOverlay.style.display = 'flex';
                chatHeader.innerText = `Talking to ${entity.npc.name} (${entity.data.name}) - ${entity.npc.traits.join(', ')}`;
                chatHistory.innerHTML = ''; // Clear history
                chatInput.focus();
                
                // Turn Pokemon to face player
                const pGridX = player.gridX;
                const pGridY = player.gridY;
                const eGridX = Math.round(entity.pixelX / ACTUAL_TILE_SIZE);
                const eGridY = Math.round(entity.pixelY / ACTUAL_TILE_SIZE);
                
                if (Math.abs(pGridX - eGridX) > Math.abs(pGridY - eGridY)) {
                    // Horizontal
                    if (pGridX > eGridX) entity.direction = 2; // Right
                    else entity.direction = 1; // Left
                } else {
                    // Vertical
                    if (pGridY > eGridY) entity.direction = 0; // Down
                    else entity.direction = 3; // Up
                }
                
                // Stop Pokemon movement (optional, looks better)
                entity.isMoving = false;
                entity.pixelX = eGridX * ACTUAL_TILE_SIZE;
                entity.pixelY = eGridY * ACTUAL_TILE_SIZE;

                // gameRunning = false; // REMOVED: Keep game loop running for rendering
                player.inDialog = true;
            }

            function closeChat() {
                chatOverlay.style.display = 'none';
                currentChatPartner = null;
                player.inDialog = false;
                // gameRunning = true; // REMOVED: Loop is already running
                chatInput.blur();
                canvas.focus(); // Focus back to canvas/window
            }

            // --- AI Text Plugin Integration ---
            // Simulierter AI Generator (Placeholder für das Plugin)
            // Das Plugin {import:ai-text-plugin} funktioniert nur auf Perchance.org Servern.
            // Die folgende Implementierung nutzt das Plugin, wenn es verfügbar ist (auf Perchance),
            // ansonsten Fallback auf Mock.
            async function generateAIResponse(entity, input) {
                const prompt = `You are ${entity.data.species}. Player says: ${input}. Respond shortly.`;
            
                return new Promise((resolve) => {
                    // Wir senden den Prompt an das Hauptfenster (Perchance)
                    window.parent.postMessage({ type: "AI_PROMPT", text: prompt }, "*");
            
                    // Wir warten einmalig auf die Antwort
                    const handler = (event) => {
                        if (event.data && event.data.type === "AI_RESPONSE") {
                            window.removeEventListener("message", handler);
                            resolve(event.data.text);
                        }
                    };
                    window.addEventListener("message", handler);
                });
            }

            async function generateMockResponse(entity, input) {
                const traits = entity.npc.traits;
                const name = entity.npc.name;
                
                // Mock Memory Update
                entity.npc.memory.push({ player: input, response: "..." });

                await new Promise(r => setTimeout(r, 500 + Math.random() * 1000)); // Fake Delay

                if (traits.includes('Aggressive')) {
                    return `*${name} growls menacingly* Leave me alone!`;
                } else if (traits.includes('Friendly')) {
                    return `*${name} jumps happily* ${entity.data.name}! (Translation: Hi friend!)`;
                } else {
                    return `*${name} stares at you blankly*`;
                }
            }
            
            async function getGreeting(entity) {
                // Auch das Greeting kann generiert werden!
                const instructionText = `You are a wild Pokemon named ${entity.npc.name} (${entity.data.name}).
Traits: ${entity.npc.traits.join(', ')}.
The player just approached you.
Give a short greeting or reaction (1 sentence).`;

                try {
                    if (typeof ai === 'function') {
                        const response = await ai({
                            instruction: instructionText
                        });
                        return response.generatedText || response;
                    }
                } catch(e) {}
                
                // Fallback Greeting
                if (entity.npc.traits.includes('Aggressive')) return "*growls*";
                if (entity.npc.traits.includes('Friendly')) return "*waves*";
                return "*looks at you*";
            }
            
            // --- Globale Variablen für Game Loop ---
            let gameRunning = false;
            let MAP_WIDTH = 1000;
            let MAP_HEIGHT = 1000;
            let animationFrameId;
            let gameMinutes = 0;
            let lastFrameTime = 0;
            const MINUTES_PER_SECOND = 1;
            let needsAccum = 0;
            const HUNGER_TICK_MINUTES = 30;
            const HUNGER_TICK_AMOUNT = 15;
            const THIRST_TICK_AMOUNT = 1;

            // Canvas Setup erst beim Start initialisieren
            let canvas, ctx, CAMERA;
            let mouseX = 0, mouseY = 0;

            function resizeCanvas() {
                if (!canvas) return;
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }

            // --- Game Start Logik ---
            function startGame(size, name) {
                console.log(`Starte Welt: ${name} (${size}x${size})`);
                MAP_WIDTH = size;
                MAP_HEIGHT = size;
                
                // UI ausblenden
                newWorldScreen.classList.add('hidden');
                debugEl.style.display = 'block';
                const bb = document.getElementById('bottom-bar');
                bb.style.display = 'flex';
                bb.classList.add('collapsed');
                
                // Canvas erstellen
                canvas = document.createElement('canvas');
                document.body.appendChild(canvas);
                ctx = canvas.getContext('2d');

                // Mouse Events für Building System
                canvas.addEventListener('mousemove', (e) => {
                    mouseX = e.clientX;
                    mouseY = e.clientY;
                });

                canvas.addEventListener('click', (e) => {
                    if (currentBuildId) {
                        const mouseTileX = Math.floor((e.clientX + CAMERA.x) / ACTUAL_TILE_SIZE);
                        const mouseTileY = Math.floor((e.clientY + CAMERA.y) / ACTUAL_TILE_SIZE);
                        
                        if (mouseTileX >= 0 && mouseTileX < MAP_WIDTH && mouseTileY >= 0 && mouseTileY < MAP_HEIGHT) {
                            const b = BUILDINGS[currentBuildId];
                            const tile = map[mouseTileY][mouseTileX];
                            
                            if (tile.walkable && !tile.object && canAfford(b.cost)) {
                                  consumeResources(b.cost);
                                  tile.object = { ...b.obj };
                                  tile.isMainTile = true; // Markiere als Haupt-Tile für Rendering
                                  tile.walkable = b.obj.walkable;
                                  
                                  // Wenn es ein Campfire ist, zur Lichtliste hinzufügen
                                  if (b.id === 'CAMPFIRE') {
                                      lightSources.push({ x: mouseTileX, y: mouseTileY, radius: 2.5 });
                                  }

                                  console.log(`${b.name} placed at ${mouseTileX}, ${mouseTileY}`);
                                  currentBuildId = null; // Bau-Modus beenden
                              }
                        }
                    }
                });

                canvas.addEventListener('contextmenu', (e) => {
                    if (currentBuildId) {
                        e.preventDefault();
                        currentBuildId = null; // Bau-Modus abbrechen
                        console.log("Building cancelled.");
                    }
                });
                
                // Resize Handler aktivieren
                window.addEventListener('resize', resizeCanvas);
                resizeCanvas();

                // Kamera initialisieren
                CAMERA = { x: 0, y: 0 };

                // Karte generieren & Loop starten
                generateMap();
                gameRunning = true;
                lastFrameTime = performance.now();
                gameMinutes = 0;
                needsAccum = 0;
                renderInventory();
                gameLoop();
            }

            const TILE_SIZE = 32;
            const SCALE = 2;
            const ACTUAL_TILE_SIZE = TILE_SIZE * SCALE;
            const MOVEMENT_SPEED = 4; // Pixel pro Frame
            const ACTIVE_RANGE = 15; // 30x30 Grids um den Spieler

            const POKEMONS = {
                BISASAM: {
                    id: 'BISASAM',
                    name: 'Bisasam',
                    type: ['Grass', 'Poison'],
                    stats: {
                        height: 0.7, // m
                        weight: 6.9, // kg
                        catchRate: 45
                    },
                    sprites: {
                        // Bitte hier die korrekten Links einfügen
                        move: 'https://images-wixmp-ed30a86b8c4ca887773594c2.wixmp.com/f/75597f3d-cbb2-4ea4-a202-11d5ab9af9a0/dljfy9k-71eccaf1-1ff2-415b-b4cf-e0a76b26933c.png?token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ1cm46YXBwOjdlMGQxODg5ODIyNjQzNzNhNWYwZDQxNWVhMGQyNmUwIiwiaXNzIjoidXJuOmFwcDo3ZTBkMTg4OTgyMjY0MzczYTVmMGQ0MTVlYTBkMjZlMCIsIm9iaiI6W1t7InBhdGgiOiIvZi83NTU5N2YzZC1jYmIyLTRlYTQtYTIwMi0xMWQ1YWI5YWY5YTAvZGxqZnk5ay03MWVjY2FmMS0xZmYyLTQxNWItYjRjZi1lMGE3NmIyNjkzM2MucG5nIn1dXSwiYXVkIjpbInVybjpzZXJ2aWNlOmZpbGUuZG93bmxvYWQiXX0.1Vgnd9XsBHTBq-Ll98WXEF1StEhXo1IQLPcsBicYwOg', 
                        front: 'https://images-wixmp-ed30a86b8c4ca887773594c2.wixmp.com/f/75597f3d-cbb2-4ea4-a202-11d5ab9af9a0/dljfy9k-2de461ea-dc32-47ae-ad54-4bfed0a873db.png?token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ1cm46YXBwOjdlMGQxODg5ODIyNjQzNzNhNWYwZDQxNWVhMGQyNmUwIiwiaXNzIjoidXJuOmFwcDo3ZTBkMTg4OTgyMjY0MzczYTVmMGQ0MTVlYTBkMjZlMCIsIm9iaiI6W1t7InBhdGgiOiIvZi83NTU5N2YzZC1jYmIyLTRlYTQtYTIwMi0xMWQ1YWI5YWY5YTAvZGxqZnk5ay0yZGU0NjFlYS1kYzMyLTQ3YWUtYWQ1NC00YmZlZDBhODczZGIucG5nIn1dXSwiYXVkIjpbInVybjpzZXJ2aWNlOmZpbGUuZG93bmxvYWQiXX0.bVPfgppo1stTEBaujdcV8RGpI7hVwRvuHQvy2jp_gDU',
                        moveShiny: 'https://images-wixmp-ed30a86b8c4ca887773594c2.wixmp.com/f/75597f3d-cbb2-4ea4-a202-11d5ab9af9a0/dljfy9k-d7727b01-5047-49f1-92fe-3dfa11ee7ad1.png?token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ1cm46YXBwOjdlMGQxODg5ODIyNjQzNzNhNWYwZDQxNWVhMGQyNmUwIiwiaXNzIjoidXJuOmFwcDo3ZTBkMTg4OTgyMjY0MzczYTVmMGQ0MTVlYTBkMjZlMCIsIm9iaiI6W1t7InBhdGgiOiIvZi83NTU5N2YzZC1jYmIyLTRlYTQtYTIwMi0xMWQ1YWI5YWY5YTAvZGxqZnk5ay1kNzcyN2IwMS01MDQ3LTQ5ZjEtOTJmZS0zZGZhMTFlZTdhZDEucG5nIn1dXSwiYXVkIjpbInVybjpzZXJ2aWNlOmZpbGUuZG93bmxvYWQiXX0.XKaIevOMGxSStz1RgjrEJ3bispdRFKcWdrv6tQHzj-4',
                        frontShiny: 'https://images-wixmp-ed30a86b8c4ca887773594c2.wixmp.com/f/75597f3d-cbb2-4ea4-a202-11d5ab9af9a0/dljfy9k-d29a7f98-961a-4c14-8434-c176c3dc0b99.png?token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ1cm46YXBwOjdlMGQxODg5ODIyNjQzNzNhNWYwZDQxNWVhMGQyNmUwIiwiaXNzIjoidXJuOmFwcDo3ZTBkMTg4OTgyMjY0MzczYTVmMGQ0MTVlYTBkMjZlMCIsIm9iaiI6W1t7InBhdGgiOiIvZi83NTU5N2YzZC1jYmIyLTRlYTQtYTIwMi0xMWQ1YWI5YWY5YTAvZGxqZnk5ay1kMjlhN2Y5OC05NjFhLTRjMTQtODQzNC1jMTc2YzNkYzBiOTkucG5nIn1dXSwiYXVkIjpbInVybjpzZXJ2aWNlOmZpbGUuZG93bmxvYWQiXX0.D9qmw6NsRmrLCe8p4ppOE1DugjXboZd3DtvCuWmNV2Y'
                    },
                    spawn: {
                        biome: 'FOREST',
                        chance: 0.02 // 2% Chance pro Tile im Forest
                    }
                }
            };

            const ITEMS = {
                SWEETBERRY: { 
                    id: 'SWEETBERRY', 
                    name: 'Sweetberry', 
                    icon: 'https://t.novaskin.me/ce69347868a803b8cc9a8e2da04d16673382f47677b35368d81e9e26eb9aa811',
                    eatable: true,
                    stockHunger: 15
                },
                STICK: {
                    id: 'STICK',
                    name: 'Stick',
                    icon: 'https://static.wikia.nocookie.net/minecraft_gamepedia/images/7/7a/Stick_JE2_BE2.png'
                },
                LOG: {
                    id: 'LOG',
                    name: 'Log',
                    icon: 'https://static.wikia.nocookie.net/minecraft_gamepedia/images/d/d4/Oak_Log_JE3_BE2.png'
                }
            };

            function addItem(id, count=1) {
                const item = ITEMS[id];
                if (!item) return false;
                const slot = player.inventory.find(s => s.id === id);
                if (slot) slot.count += count;
                else player.inventory.push({ id, count });
                if (document.getElementById('bottom-bar').style.display !== 'none') renderInventory();
                return true;
            }

            function renderInventory() {
                const panel = document.getElementById('inventory-panel');
                if (!panel) return;
                const slots = 30;
                const arr = [];
                const inv = [...player.inventory];
                for (let i=0;i<slots;i++) {
                    const s = inv[i];
                    if (s) {
                        const it = ITEMS[s.id];
                        arr.push(`<div class="inv-slot" data-item-id="${s.id}" data-slot-index="${i}"><img src="${it.icon}" onerror="this.style.display='none'"><span class="inv-count">${s.count}</span></div>`);
                    } else {
                        arr.push('<div class="inv-slot"></div>');
                    }
                }
                panel.innerHTML = arr.join('');

                // Rechtsklick Event für Slots
                panel.querySelectorAll('.inv-slot').forEach(slot => {
                    slot.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        const itemId = slot.getAttribute('data-item-id');
                        if (!itemId) return;

                        showContextMenu(e.clientX, e.clientY, itemId);
                    });
                });
            }

            const contextMenu = document.getElementById('context-menu');
            
            function showContextMenu(x, y, itemId) {
                const itemDef = ITEMS[itemId];
                if (!itemDef) return;

                contextMenu.innerHTML = '';
                
                if (itemDef.eatable) {
                    const eatBtn = document.createElement('div');
                    eatBtn.className = 'context-menu-item';
                    eatBtn.innerText = 'Eat';
                    eatBtn.onclick = () => {
                        eatItem(itemId);
                        hideContextMenu();
                    };
                    contextMenu.appendChild(eatBtn);
                }

                // Schließe Menü bei Linksklick irgendwo anders
                const closeMenu = () => {
                    hideContextMenu();
                    document.removeEventListener('click', closeMenu);
                };
                setTimeout(() => document.addEventListener('click', closeMenu), 10);

                if (contextMenu.children.length > 0) {
                    contextMenu.style.left = `${x}px`;
                    contextMenu.style.top = `${y}px`;
                    contextMenu.style.display = 'block';
                }
            }

            function hideContextMenu() {
                contextMenu.style.display = 'none';
            }

            // Globaler Eventlistener für Rechtsklicks außerhalb des Inventars, um das Standard-Kontextmenü zu unterbinden (optional, aber sauberer)
            document.addEventListener('contextmenu', (e) => {
                if (!e.target.closest('.inv-slot')) {
                    hideContextMenu();
                }
            });

            function eatItem(itemId) {
                const itemDef = ITEMS[itemId];
                const invItem = player.inventory.find(s => s.id === itemId);
                
                if (invItem && invItem.count > 0) {
                    // Hunger auffüllen
                    player.hunger = Math.min(100, player.hunger + (itemDef.stockHunger || 5));
                    
                    // Item verbrauchen
                    invItem.count--;
                    if (invItem.count <= 0) {
                        player.inventory = player.inventory.filter(s => s.id !== itemId);
                    }
                    
                    renderInventory();
                    console.log(`Ate ${itemDef.name}. Hunger is now ${player.hunger}%`);
                }
            }

            // Verbesserter Textur Generator für Fallback (wenn kein Bild gefunden wird)
            // Erzeugt prozedurale Pixel-Art Texturen statt einfachem Rauschen
            function createProceduralTexture(biomeId, baseColor, variant = 0) {
                const offCanvas = document.createElement('canvas');
                offCanvas.width = 32;
                offCanvas.height = 32;
                const offCtx = offCanvas.getContext('2d');
                
                // Basis Farbe
                offCtx.fillStyle = baseColor;
                offCtx.fillRect(0, 0, 32, 32);
                
                // Muster je nach Biom zeichnen
                if (biomeId === 'WATER') {
                    offCtx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                    // Wellen
                    for(let y=4; y<32; y+=8) {
                        offCtx.fillRect(0, y, 32, 2);
                    }
                } else if (biomeId === 'PLAINS') {
                    offCtx.fillStyle = 'rgba(0, 100, 0, 0.2)';
                    // Grashalme
                    for(let i=0; i<60; i++) {
                        const x = Math.floor(Math.random() * 32);
                        const y = Math.floor(Math.random() * 32);
                        offCtx.fillRect(x, y, 1, 2);
                    }
                    
                    // Variante 1: Blumen
                    if (variant === 1) {
                        for(let i=0; i<8; i++) {
                            const x = Math.floor(Math.random() * 28) + 2;
                            const y = Math.floor(Math.random() * 28) + 2;
                            // Blüte
                            offCtx.fillStyle = Math.random() > 0.5 ? '#ffcccc' : '#ffffcc'; // Rosa oder Gelb
                            offCtx.fillRect(x, y, 2, 2);
                            // Stängel
                            offCtx.fillStyle = '#006600';
                            offCtx.fillRect(x, y+2, 1, 2);
                        }
                    }
                } else if (biomeId === 'FOREST') {
                    offCtx.fillStyle = 'rgba(0, 50, 0, 0.3)';
                    // Kleine Tannen/Büsche
                    for(let i=0; i<15; i++) {
                        const x = Math.floor(Math.random() * 28);
                        const y = Math.floor(Math.random() * 28);
                        offCtx.beginPath();
                        offCtx.moveTo(x, y+6);
                        offCtx.lineTo(x+6, y);
                        offCtx.lineTo(x+12, y+6);
                        offCtx.fill();
                    }
                } else if (biomeId === 'SAND') {
                    offCtx.fillStyle = 'rgba(200, 180, 100, 0.3)';
                    // Sandkörner
                    for(let i=0; i<100; i++) {
                        const x = Math.floor(Math.random() * 32);
                        const y = Math.floor(Math.random() * 32);
                        offCtx.fillRect(x, y, 1, 1);
                    }
                } else if (biomeId === 'MOUNTAIN') {
                    offCtx.fillStyle = 'rgba(50, 50, 50, 0.3)';
                    // Felsbrocken
                    for(let i=0; i<20; i++) {
                        const w = 2 + Math.floor(Math.random() * 4);
                        const h = 2 + Math.floor(Math.random() * 4);
                        const x = Math.floor(Math.random() * (32 - w));
                        const y = Math.floor(Math.random() * (32 - h));
                        offCtx.fillRect(x, y, w, h);
                    }
                } else if (biomeId === 'BUSH') {
                    offCtx.fillStyle = '#00aa00';
                    // Busch Form
                    offCtx.beginPath();
                    offCtx.arc(16, 16, 12, 0, Math.PI * 2);
                    offCtx.fill();
                    // Beeren
                    offCtx.fillStyle = '#ff0000';
                    offCtx.fillRect(12, 12, 2, 2);
                    offCtx.fillRect(20, 14, 2, 2);
                    offCtx.fillRect(15, 20, 2, 2);
                } else if (biomeId === 'CAMPFIRE') {
                    // Fallback Campfire
                    offCtx.fillStyle = '#663300'; // Holz
                    offCtx.fillRect(8, 20, 16, 4);
                    offCtx.fillStyle = '#ff6600'; // Feuer
                    offCtx.beginPath();
                    offCtx.moveTo(16, 8);
                    offCtx.lineTo(24, 20);
                    offCtx.lineTo(8, 20);
                    offCtx.fill();
                } else {
                    // Fallback Rauschen
                    for(let i=0; i<200; i++) {
                        const x = Math.floor(Math.random() * 32);
                        const y = Math.floor(Math.random() * 32);
                        offCtx.fillStyle = `rgba(0,0,0,${Math.random() * 0.1})`;
                        offCtx.fillRect(x, y, 1, 1);
                    }
                }
                
                return offCanvas.toDataURL();
            }

            // Biome Definitionen
            // HIER BILDER EINFÜGEN:
            // Du kannst nun auch ein Array [] von Bildern angeben für Variationen!
            // Globale Wetter-Zustände
            const GLOBAL_WEATHERS = ['CLEAR', 'CLOUDY', 'RAIN', 'STORM'];
            let currentGlobalWeather = 'CLEAR';
            let weatherTimer = 120; // Minuten bis zum nächsten Wechsel

            const BIOMES = {
                WATER: { 
                    id: 'WATER', 
                    name: 'Ozean', 
                    color: '#4444ff',
                    imageSrc: 'https://images-wixmp-ed30a86b8c4ca887773594c2.wixmp.com/f/75597f3d-cbb2-4ea4-a202-11d5ab9af9a0/dljgpqs-0bd1b07a-69fa-4b78-90f1-2500f93b6da1.png/v1/fill/w_32,h_32,q_80,strp/water_by_ulquiorrasm_dljgpqs-fullview.jpg?token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ1cm46YXBwOjdlMGQxODg5ODIyNjQzNzNhNWYwZDQxNWVhMGQyNmUwIiwiaXNzIjoidXJuOmFwcDo3ZTBkMTg4OTgyMjY0MzczYTVmMGQ0MTVlYTBkMjZlMCIsIm9iaiI6W1t7ImhlaWdodCI6Ijw9MzIiLCJwYXRoIjoiL2YvNzU1OTdmM2QtY2JiMi00ZWE0LWEyMDItMTFkNWFiOWFmOWEwL2RsamdwcXMtMGJkMWIwN2EtNjlmYS00Yjc4LTkwZjEtMjUwMGY5M2I2ZGExLnBuZyIsIndpZHRoIjoiPD0zMiJ9XV0sImF1ZCI6WyJ1cm46c2VydmljZTppbWFnZS5vcGVyYXRpb25zIl19.W56mH_mJArRLRJ7vAukwmIMWCCQab9J1mCSA-3Yv9G8', 
                    walkable: false,
                    clima: {
                        CLEAR: { weather: 'Sunny', temp: 18, humidity: 80 },
                        CLOUDY: { weather: 'Foggy', temp: 16, humidity: 90 },
                        RAIN: { weather: 'Rainy', temp: 14, humidity: 100 },
                        STORM: { weather: 'Stormy', temp: 12, humidity: 100 }
                    }
                },
                PLAINS: { 
                    id: 'PLAINS', 
                    name: 'Ebene', 
                    color: '#44cc44', 
                    imageSrc: [
                        'https://images-wixmp-ed30a86b8c4ca887773594c2.wixmp.com/f/75597f3d-cbb2-4ea4-a202-11d5ab9af9a0/dljezqu-414b8c8a-0fb6-4cd4-bb04-d0948cccdddc.png/v1/fill/w_32,h_32,q_80,strp/plant1_by_ulquiorrasm_dljezqu-fullview.jpg?token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ1cm46YXBwOjdlMGQxODg5ODIyNjQzNzNhNWYwZDQxNWVhMGQyNmUwIiwiaXNzIjoidXJuOmFwcDo3ZTBkMTg4OTgyMjY0MzczYTVmMGQ0MTVlYTBkMjZlMCIsIm9iaiI6W1t7ImhlaWdodCI6Ijw9MzIiLCJwYXRoIjoiL2YvNzU1OTdmM2QtY2JiMi00ZWE0LWEyMDItMTFkNWFiOWFmOWEwL2RsamV6cXUtNDE0YjhjOGEtMGZiNi00Y2Q0LWJiMDQtZDA5NDhjY2NkZGRjLnBuZyIsIndpZHRoIjoiPD0zMiJ9XV0sImF1ZCI6WyJ1cm46c2VydmljZTppbWFnZS5vcGVyYXRpb25zIl19.UTmF5WMtEwc6c8gS_il44tJYZTGiAqNc3BDqMlGsTYg',
                        'https://images-wixmp-ed30a86b8c4ca887773594c2.wixmp.com/f/75597f3d-cbb2-4ea4-a202-11d5ab9af9a0/dljezqu-11f8fdcb-81e4-40d4-acdd-ad7318c8b516.png?token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ1cm46YXBwOjdlMGQxODg5ODIyNjQzNzNhNWYwZDQxNWVhMGQyNmUwIiwiaXNzIjoidXJuOmFwcDo3ZTBkMTg4OTgyMjY0MzczYTVmMGQ0MTVlYTBkMjZlMCIsIm9iaiI6W1t7InBhdGgiOiIvZi83NTU5N2YzZC1jYmIyLTRlYTQtYTIwMi0xMWQ1YWI5YWY5YTAvZGxqZXpxdS0xMWY4ZmRjYi04MWU0LTQwZDQtYWNkZC1hZDczMThjOGI1MTYucG5nIn1dXSwiYXVkIjpbInVybjpzZXJ2aWNlOmZpbGUuZG93bmxvYWQiXX0.iMeIm7yUNg7gPrViTU-WepSX3y_zjiggUmzODRtQnOI'
                    ],
                    walkable: true,
                    clima: {
                        CLEAR: { weather: 'Sunny', temp: 22, humidity: 40 },
                        CLOUDY: { weather: 'Overcast', temp: 20, humidity: 60 },
                        RAIN: { weather: 'Rainy', temp: 18, humidity: 80 },
                        STORM: { weather: 'Heavy Rain', temp: 16, humidity: 95 }
                    }
                },
                FOREST: { 
                    id: 'FOREST', 
                    name: 'Wald', 
                    color: '#006600', 
                    imageSrc: 'forest_32x32.png', 
                    walkable: true,
                    clima: {
                        CLEAR: { weather: 'Sunny', temp: 16, humidity: 60 },
                        CLOUDY: { weather: 'Mist', temp: 14, humidity: 80 },
                        RAIN: { weather: 'Drizzle', temp: 12, humidity: 90 },
                        STORM: { weather: 'Stormy', temp: 10, humidity: 100 }
                    }
                },
                SAND: { 
                    id: 'SAND', 
                    name: 'Wüste', 
                    color: '#eeee88',
                    imageSrc: 'https://images-wixmp-ed30a86b8c4ca887773594c2.wixmp.com/f/75597f3d-cbb2-4ea4-a202-11d5ab9af9a0/dljgp70-5280a709-a6f1-43c4-9a11-53aefd4386fe.png/v1/fill/w_32,h_32,q_80,strp/desert_by_ulquiorrasm_dljgp70-fullview.jpg?token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ1cm46YXBwOjdlMGQxODg5ODIyNjQzNzNhNWYwZDQxNWVhMGQyNmUwIiwiaXNzIjoidXJuOmFwcDo3ZTBkMTg4OTgyMjY0MzczYTVmMGQ0MTVlYTBkMjZlMCIsIm9iaiI6W1t7ImhlaWdodCI6Ijw9MzIiLCJwYXRoIjoiL2YvNzU1OTdmM2QtY2JiMi00ZWE0LWEyMDItMTFkNWFiOWFmOWEwL2RsamdwNzAtNTI4MGE3MDktYTZmMS00M2M0LTlhMTEtNTNhZWZkNDM4NmZlLnBuZyIsIndpZHRoIjoiPD0zMiJ9XV0sImF1ZCI6WyJ1cm46c2VydmljZTppbWFnZS5vcGVyYXRpb25zIl19.1PpH03j21ZcJv0-DD3ih1RFVIeAWPKYM_aIlB3zjN5s',
                    walkable: true,
                    clima: {
                        CLEAR: { weather: 'Heatwave', temp: 38, humidity: 10 },
                        CLOUDY: { weather: 'Dusty', temp: 34, humidity: 20 },
                        RAIN: { weather: 'Light Rain', temp: 30, humidity: 40 },
                        STORM: { weather: 'Sandstorm', temp: 28, humidity: 50 }
                    }
                },
                MOUNTAIN: { 
                    id: 'MOUNTAIN', 
                    name: 'Gebirge', 
                    color: '#888888',
                    imageSrc: 'stone_32x32.png',
                    walkable: false,
                    clima: {
                        CLEAR: { weather: 'Clear', temp: 4, humidity: 20 },
                        CLOUDY: { weather: 'Foggy', temp: 0, humidity: 40 },
                        RAIN: { weather: 'Sleet', temp: -2, humidity: 60 },
                        STORM: { weather: 'Blizzard', temp: -8, humidity: 90 }
                    }
                }
            };

            // Objekte Definitionen (Overlay Layer)
            const OBJECTS = {
                BUSH: {
                    id: 'BUSH',
                    name: 'Busch',
                    imageSrc: [
                        'https://images-wixmp-ed30a86b8c4ca887773594c2.wixmp.com/f/75597f3d-cbb2-4ea4-a202-11d5ab9af9a0/dljfex1-4ae07ba9-6cf6-43a2-b2e8-efc33c22d720.png/v1/fill/w_32,h_32/bush_by_ulquiorrasm_dljfex1-fullview.png?token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ1cm46YXBwOjdlMGQxODg5ODIyNjQzNzNhNWYwZDQxNWVhMGQyNmUwIiwiaXNzIjoidXJuOmFwcDo3ZTBkMTg4OTgyMjY0MzczYTVmMGQ0MTVlYTBkMjZlMCIsIm9iaiI6W1t7ImhlaWdodCI6Ijw9MzIiLCJwYXRoIjoiL2YvNzU1OTdmM2QtY2JiMi00ZWE0LWEyMDItMTFkNWFiOWFmOWEwL2RsamZleDEtNGFlMDdiYTktNmNmNi00M2EyLWIyZTgtZWZjMzNjMjJkNzIwLnBuZyIsIndpZHRoIjoiPD0zMiJ9XV0sImF1ZCI6WyJ1cm46c2VydmljZTppbWFnZS5vcGVyYXRpb25zIl19.CX3BGvuNNwy7AZdZxssCViO6OyIAobLkVjU9MRSB7Fg',
                        'https://images-wixmp-ed30a86b8c4ca887773594c2.wixmp.com/f/75597f3d-cbb2-4ea4-a202-11d5ab9af9a0/dljfex1-4b669053-dd26-438b-ae05-e00da37491fa.png?token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ1cm46YXBwOjdlMGQxODg5ODIyNjQzNzNhNWYwZDQxNWVhMGQyNmUwIiwiaXNzIjoidXJuOmFwcDo3ZTBkMTg4OTgyMjY0MzczYTVmMGQ0MTVlYTBkMjZlMCIsIm9iaiI6W1t7InBhdGgiOiIvZi83NTU5N2YzZC1jYmIyLTRlYTQtYTIwMi0xMWQ1YWI5YWY5YTAvZGxqZmV4MS00YjY2OTA1My1kZDI2LTQzOGItYWUwNS1lMDBkYTM3NDkxZmEucG5nIn1dXSwiYXVkIjpbInVybjpzZXJ2aWNlOmZpbGUuZG93bmxvYWQiXX0.kMDiFUd4mdIqv66-OgNWkpyJ3GlZb6ptdl8a7eaqelo'
                    ],
                    walkable: false // Blockiert den Weg
                },
                TREE: {
                    id: 'TREE',
                    name: 'Baum',
                    imageSrc: 'https://images-wixmp-ed30a86b8c4ca887773594c2.wixmp.com/f/75597f3d-cbb2-4ea4-a202-11d5ab9af9a0/dljfex1-d5a1d3ee-2ae1-4825-a3f8-829de4766ea6.png?token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ1cm46YXBwOjdlMGQxODg5ODIyNjQzNzNhNWYwZDQxNWVhMGQyNmUwIiwiaXNzIjoidXJuOmFwcDo3ZTBkMTg4OTgyMjY0MzczYTVmMGQ0MTVlYTBkMjZlMCIsIm9iaiI6W1t7InBhdGgiOiIvZi83NTU5N2YzZC1jYmIyLTRlYTQtYTIwMi0xMWQ1YWI5YWY5YTAvZGxqZmV4MS1kNWExZDNlZS0yYWUxLTQ4MjUtYTNmOC04MjlkZTQ3NjZlYTYucG5nIn1dXSwiYXVkIjpbInVybjpzZXJ2aWNlOmZpbGUuZG93bmxvYWQiXX0.8-uhWF9abtAPgNPneVMrRnVpAk1uP74Bdg13jF_-VWc',
                    width: 2,   // Breite in Tiles
                    height: 3,  // Höhe in Tiles
                    walkable: false // Spezielle Kollision wird separat behandelt
                },
                CAMPFIRE: {
                    id: 'CAMPFIRE',
                    name: 'Campfire',
                    imageSrc: 'https://opengameart.org/sites/default/files/fire1_2.png',
                    width: 1,
                    height: 1,
                    walkable: false
                }
            };

            const BUILDINGS = {
                CAMPFIRE: {
                    id: 'CAMPFIRE',
                    name: 'Campfire',
                    cost: { STICK: 4 },
                    obj: OBJECTS.CAMPFIRE
                }
            };

            // --- NPC / Entity Helper ---
            const TRAITS = ['Brave', 'Timid', 'Glutton', 'Runner', 'Lazy', 'Aggressive', 'Friendly', 'Loner', 'Social', 'HardWorker', 'NightOwl'];
            const NPC_NAMES = ['Sparky', 'Leafy', 'Buddy', 'Chomper', 'Speedy', 'Dozer', 'Rocky', 'Shadow', 'Sunny', 'Luna', 'Spike', 'Bubbles', 'Rex', 'Misty', 'Brock'];

            function generateUUID() {
                return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                    var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
                    return v.toString(16);
                });
            }

            function generateRandomTraits() {
                const num = Math.floor(Math.random() * 3) + 1; // 1-3 traits
                const shuffled = [...TRAITS].sort(() => 0.5 - Math.random());
                return shuffled.slice(0, num);
            }

            function generateRandomName(speciesName) {
                if (Math.random() > 0.5) {
                    return NPC_NAMES[Math.floor(Math.random() * NPC_NAMES.length)];
                }
                return speciesName; // 50% Chance einfach den Spezies-Namen zu behalten
            }

            function generateBirthDate(age) {
                // Simuliertes Geburtsdatum basierend auf Alter
                // Wir nehmen an, Jahr 100 ist Spielstart
                const currentYear = 100; // Spieljahr
                const birthYear = currentYear - age;
                const birthDay = Math.floor(Math.random() * 60) + 1; // 60 Tage pro Jahr (fiktiv)
                const birthQuadrum = Math.floor(Math.random() * 4) + 1; // 4 Jahreszeiten/Quadrums
                return `Year ${birthYear}, Quadrum ${birthQuadrum}, Day ${birthDay}`;
            }

            // Bilder laden
            const images = {};
            let imagesLoaded = 0;
            let totalImages = 0;

            function loadImages() {
                console.log("Starte Bild-Laden...");
                
                // 1. Biome Bilder laden
                for (const key in BIOMES) {
                    const biome = BIOMES[key];
                    loadImageArray(biome.id, biome.imageSrc, biome.color);
                }

                // 2. Objekt Bilder laden
                for (const key in OBJECTS) {
                    const obj = OBJECTS[key];
                    loadImageArray(obj.id, obj.imageSrc, '#00ff00');
                }

                // 3. Pokemon Bilder laden
                for (const key in POKEMONS) {
                    const poke = POKEMONS[key];
                    // Wir nutzen "poke.id" + "_MOVE" und "_FRONT" als keys
                    loadImageArray(poke.id + '_MOVE', poke.sprites.move, '#000000');
                    loadImageArray(poke.id + '_FRONT', poke.sprites.front, '#000000');
                    // Shiny
                    if(poke.sprites.moveShiny) loadImageArray(poke.id + '_MOVE_SHINY', poke.sprites.moveShiny, '#000000');
                    if(poke.sprites.frontShiny) loadImageArray(poke.id + '_FRONT_SHINY', poke.sprites.frontShiny, '#000000');
                }
            }

            function loadImageArray(id, source, fallbackColor) {
                // Normalisiere imageSrc zu Array
                const srcArray = Array.isArray(source) ? source : [source];
                
                images[id] = []; // Array für geladene Bilder
                
                srcArray.forEach((src, index) => {
                    if (!src) return;
                    
                    totalImages++;
                    const img = new Image();
                    // crossOrigin entfernt, da viele Hoster CORS blocken und Bilder dann nicht laden
                    img.src = src;
                    
                    // Handler für erfolgreiches Laden
                    img.onload = () => {
                        if (img.naturalWidth === 0) {
                            console.warn(`⚠️ Bild geladen aber leer: ${id} (Var ${index})`);
                            triggerFallback(id, fallbackColor, index);
                            return;
                        }
                        console.log(`✅ Bild geladen: ${id} (Var ${index})`);
                        imagesLoaded++;
                    };
                    
                    // Handler für Fehler
                    img.onerror = (e) => {
                        console.warn(`⚠️ Bild-Fehler für ${id} (Var ${index}):`, e);
                        triggerFallback(id, fallbackColor, index);
                    };
                    
                    // Speichere Referenz sofort
                    images[id][index] = img;
                });
            }

            function triggerFallback(id, color, index) {
                // Fallback Variante erzeugen
                const fallbackSrc = createProceduralTexture(id, color, index);
                const fallbackImg = new Image();
                fallbackImg.src = fallbackSrc;
                images[id][index] = fallbackImg;
                imagesLoaded++;
                console.log(`🎨 Fallback-Textur generiert für ${id} (Var ${index})`);
            }
            
            loadImages();

            // Spielzustand
            const player = {
                gridX: 5,
                gridY: 5,
                pixelX: 5 * ACTUAL_TILE_SIZE,
                pixelY: 5 * ACTUAL_TILE_SIZE,
                color: '#ff0000',
                isMoving: false,
                targetPixelX: 0,
                targetPixelY: 0,
                direction: 0, // 0: Down, 1: Left, 2: Right, 3: Up (Konsistent mit Pokemon)
                inDialog: false,
                hunger: 100,
                thirst: 100,
                inventory: []
            };

            // Karte generieren
            const map = [];
            const entities = []; // Liste für aktive Pokemon/Entities
            const harvestedBushes = []; // Büsche, die gerade regenerieren
            const lightSources = []; // NEU: Lichtquellen (Campfires)
            
            // Noise Implementation für schönere Biome
            const Perlin = {
                grad3: [[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0], 
                        [1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1], 
                        [0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]], 
                p: [],
                perm: [],
                init: function() {
                    this.p = [];
                    for (let i=0; i<256; i++) {
                        this.p[i] = Math.floor(Math.random()*256);
                    }
                    this.perm = [];
                    for(let i=0; i<512; i++) {
                        this.perm[i] = this.p[i & 255];
                    }
                },
                dot: function(g, x, y) {
                    return g[0]*x + g[1]*y; 
                },
                mix: function(a, b, t) { 
                    return (1-t)*a + t*b; 
                },
                fade: function(t) { 
                    return t*t*t*(t*(t*6-15)+10); 
                },
                noise: function(x, y) {
                    // Find unit grid cell containing point
                    let X = Math.floor(x);
                    let Y = Math.floor(y);
                    // Get relative xy coordinates of point within that cell
                    x = x - X;
                    y = y - Y;
                    // Wrap the integer cells at 255 (smaller integer period can be introduced here)
                    X = X & 255;
                    Y = Y & 255;
                    
                    // Calculate a set of eight hashed gradient indices
                    let gi00 = this.perm[X+this.perm[Y]] % 12;
                    let gi01 = this.perm[X+this.perm[Y+1]] % 12;
                    let gi10 = this.perm[X+1+this.perm[Y]] % 12;
                    let gi11 = this.perm[X+1+this.perm[Y+1]] % 12;
                    
                    // Calculate noise contributions from each of the four corners
                    let n00 = this.dot(this.grad3[gi00], x, y);
                    let n10 = this.dot(this.grad3[gi10], x-1, y);
                    let n01 = this.dot(this.grad3[gi01], x, y-1);
                    let n11 = this.dot(this.grad3[gi11], x-1, y-1);
                    
                    // Compute the fade curve value for each of x and y
                    let u = this.fade(x);
                    let v = this.fade(y);
                    
                    // Interpolate the four results
                    return this.mix(
                        this.mix(n00, n10, u),
                        this.mix(n01, n11, u),
                        v
                    );
                }
            };
            Perlin.init();

            function generateMap() {
                // Karte zurücksetzen
                map.length = 0;
                entities.length = 0;

                // Seed für Perlin Noise neu initialisieren
                Perlin.init();
                
                // Parameter für die Generierung
                const scale = 0.1; // Wie "groß" die Biome sind (kleiner = größer)
                
                for (let y = 0; y < MAP_HEIGHT; y++) {
                    const row = [];
                    for (let x = 0; x < MAP_WIDTH; x++) {
                        // Perlin Noise Wert abholen (gibt ca. -1 bis 1 zurück)
                        let value = Perlin.noise(x * scale, y * scale);
                        
                        // Ozean-Rand (Insel-Form)
                        // Wir nutzen einen radialen Gradienten, um die Ränder abzusenken (zu Wasser zu machen)
                        // Koordinaten normalisieren (-1 bis 1)
                        const nx = (x / MAP_WIDTH) * 2 - 1;
                        const ny = (y / MAP_HEIGHT) * 2 - 1;
                        
                        // Distanz vom Zentrum (0 bis ca. 1.41 am Eck)
                        // Wir nutzen euklidische Distanz für eine runde Insel, oder max(abs(nx), abs(ny)) für quadratisch
                        // Eine leichte Mischung oder einfach Distanz ^ Exponent sorgt für flache Mitte und steile Ränder
                        const d = Math.sqrt(nx*nx + ny*ny);
                        
                        // Maske anwenden: Je weiter außen, desto mehr ziehen wir vom Wert ab
                        // d^2 sorgt dafür, dass die Mitte (d < 0.5) kaum beeinflusst wird
                        // Faktor 1.5 sorgt dafür, dass bei d=1 (Rand) sicher Wasser ist (Wert - 1.5)
                        const mask = Math.pow(d, 2.5); 
                        
                        // Wert absenken
                        value = value - mask;

                        let tileTemplate = BIOMES.PLAINS;
                        
                        // Biome basierend auf "Höhe" (Noise Wert) zuweisen
                        if (value < -0.3) tileTemplate = BIOMES.WATER;      // Tiefes Wasser
                        else if (value < -0.15) tileTemplate = BIOMES.SAND; // Strand
                        else if (value < 0.3) tileTemplate = BIOMES.PLAINS; // Ebene
                        else if (value < 0.6) tileTemplate = BIOMES.FOREST; // Wald
                        else tileTemplate = BIOMES.MOUNTAIN;                // Gebirge

                        // Variation bestimmen (bleibt zufällig innerhalb des Bioms)
                        const srcArray = Array.isArray(tileTemplate.imageSrc) ? tileTemplate.imageSrc : [tileTemplate.imageSrc];
                        const variantIndex = Math.floor(Math.random() * srcArray.length);

                        // Kopie des Bioms erstellen mit spezifischer Variante
                        const tile = {
                            ...tileTemplate,
                            variantIndex: variantIndex,
                            object: null // Platzhalter für Objekte wie Büsche
                        };
                        
                        row.push(tile);
                    }
                    map.push(row);
                }

                // ZWEITER DURCHLAUF: Objekte setzen (Greedy)
                // Wir iterieren durch die Karte und setzen Objekte, wenn Platz ist.
                // Da wir "in-place" arbeiten, müssen wir nicht zwei Passes machen.
                for (let y = 0; y < MAP_HEIGHT; y++) {
                    for (let x = 0; x < MAP_WIDTH; x++) {
                        const tile = map[y][x];

                        // Wenn bereits ein Objekt da ist (durch vorherige Iteration gesetzt), überspringen
                        if (tile.object) continue;

                        // Büsche spawnen (Single Tile)
                        if (tile.id === 'PLAINS' && Math.random() < 0.05) {
                            tile.object = { ...OBJECTS.BUSH, harvestable: true };
                            tile.walkable = false;
                            continue;
                        }

                        // Bäume spawnen (Multi Tile)
                        // FOREST: 20% Chance, PLAINS: 1% Chance
                        // WICHTIG: Wir checken hier den UNTERGRUND (Stamm).
                        // NEU: Wir checken BEIDE unteren Tiles (Links und Rechts bei Breite 2), damit der Baum nicht halb auf Wasser/Sand steht.
                        
                        let spawnChance = 0;
                        const treeW = OBJECTS.TREE.width;
                        const treeH = OBJECTS.TREE.height;

                        // Wir brauchen Platz nach rechts für den Stamm (Breite 2)
                        if (x + treeW <= MAP_WIDTH) {
                             const tileLeft = map[y][x];
                             const tileRight = map[y][x+1]; // treeW=2, also x+1

                             const isValidTreeGround = (t) => t.id === 'FOREST' || t.id === 'PLAINS';

                             if (isValidTreeGround(tileLeft) && isValidTreeGround(tileRight)) {
                                 // Bestimme Chance basierend auf Dominanz
                                 if (tileLeft.id === 'FOREST' || tileRight.id === 'FOREST') {
                                     spawnChance = 0.2; // Wald oder Waldrand
                                 } else {
                                     spawnChance = 0.01; // Nur Ebene
                                 }
                             }
                        }

                        if (spawnChance > 0 && Math.random() < spawnChance) {
                            const w = treeW;
                            const h = treeH;

                            // Berechne die Position der oberen linken Ecke basierend auf dem aktuellen Tile (unten links)
                            // Das aktuelle Tile (x, y) soll der linke Teil des Stamms sein (unterste Reihe, linke Spalte)
                            // Die Baum-Dimensionen sind 2x3 (BxH).
                            // Wenn (x,y) der linke Stammteil ist, dann ist (x, y - h + 1) die obere linke Ecke.
                            
                            const topY = y - h + 1;
                            
                            // Check ob der Baum innerhalb der Karte liegt
                            if (topY >= 0 && x + w <= MAP_WIDTH) {
                                let spaceFree = true;
                                
                                // Prüfen ob der Bereich frei von Objekten ist (im Bereich [topY, y] und [x, x+w])
                                for(let dy=0; dy<h; dy++) {
                                    for(let dx=0; dx<w; dx++) {
                                        const checkY = topY + dy;
                                        const checkX = x + dx;
                                        
                                        // Ist dort schon ein Objekt?
                                        if (map[checkY][checkX].object) {
                                            spaceFree = false;
                                            break;
                                        }
                                        
                                        // Optional: Prüfen ob Untergrund valide ist (nicht Wasser/Berg)
                                        // Besonders wichtig für die Basis des Baums (dy=h-1)
                                        // Wir wollen, dass der Stamm auf begehbarem Grund steht.
                                        if (dy === h-1 && !map[checkY][checkX].walkable) {
                                             spaceFree = false;
                                             break;
                                        }
                                    }
                                    if(!spaceFree) break;
                                }

                                if(spaceFree) {
                                    // Baum setzen
                                    for(let dy=0; dy<h; dy++) {
                                        for(let dx=0; dx<w; dx++) {
                                            const targetY = topY + dy;
                                            const targetX = x + dx;
                                            const targetTile = map[targetY][targetX];
                                            
                                            if (dx===0 && dy===0) {
                                                // Ankerpunkt (oben links)
                                                targetTile.object = OBJECTS.TREE;
                                                targetTile.isMainTile = true;
                                                targetTile.walkable = true; // Krone ist begehbar
                                            } else {
                                                // Teil des Baums
                                                targetTile.object = { ...OBJECTS.TREE, isPart: true, mainX: x, mainY: topY };
                                                
                                                // Kollisionslogik:
                                                // Oberste Reihen (dy=0, dy=1) sind begehbar (Krone)
                                                // Untere Reihe (dy=2) ist blockiert (Stamm)
                                                if (dy > 1) {
                                                    targetTile.walkable = false;
                                                } else {
                                                    targetTile.walkable = true; // Krone begehbar
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                // DRITTER DURCHLAUF: Entities (Pokemon) spawnen
                // Pokemon sind dynamische Objekte, die nicht fest im Grid verankert sind (aber grid-aligned starten)
                for (let y = 0; y < MAP_HEIGHT; y++) {
                    for (let x = 0; x < MAP_WIDTH; x++) {
                        const tile = map[y][x];
                        
                        // Pokemon spawnen nur auf begehbaren Tiles ohne Objekte
                        if (!tile.walkable || tile.object) continue;

                        for (const key in POKEMONS) {
                            const poke = POKEMONS[key];
                            if (tile.id === poke.spawn.biome && Math.random() < poke.spawn.chance) {
                                // Pokemon spawnen!
                                const age = Math.floor(Math.random() * 20) + 1; // 1-20 Jahre alt
                                
                                entities.push({
                                    id: generateUUID(),
                                    type: 'POKEMON',
                                    data: poke,
                                    // Individual NPC Data (RimWorld style)
                                    npc: {
                                        name: generateRandomName(poke.name),
                                        gender: Math.random() > 0.5 ? 'Male' : 'Female', // Geschlecht
                                        memory: [], // Gesprächshistorie
                                        hunger: 100, // 0-100 (100 = Voll)
                                        thirst: 100, // 0-100 (100 = Hydriert)
                                        traits: generateRandomTraits(),
                                        age: age,
                                        birthDate: generateBirthDate(age)
                                    },
                                    gridX: x,
                                    gridY: y,
                                    pixelX: x * ACTUAL_TILE_SIZE,
                                    pixelY: y * ACTUAL_TILE_SIZE,
                                    direction: 0, // 0: Down, 1: Left, 2: Right, 3: Up
                                    frame: 0,
                                    isMoving: false,
                                    targetPixelX: x * ACTUAL_TILE_SIZE,
                                    targetPixelY: y * ACTUAL_TILE_SIZE,
                                    animTimer: 0
                                });
                                break; // Nur ein Pokemon pro Tile
                            }
                        }
                    }
                }

                // Startposition sicherstellen
                // Suche nach einem gültigen Spawnpunkt (nicht Wasser, kein Objekt, begehbar)
                let validSpawnFound = false;
                let attempts = 0;
                while (!validSpawnFound && attempts < 1000) {
                    const randX = Math.floor(Math.random() * MAP_WIDTH);
                    const randY = Math.floor(Math.random() * MAP_HEIGHT);
                    const tile = map[randY][randX];

                    // Kriterien:
                    // 1. Begehbar (walkable)
                    // 2. Kein Objekt (object === null)
                    // 3. Kein Wasser (id !== 'WATER')
                    if (tile.walkable && !tile.object && tile.id !== 'WATER') {
                        player.gridX = randX;
                        player.gridY = randY;
                        validSpawnFound = true;
                    }
                    attempts++;
                }

                // Fallback falls nichts gefunden (sehr unwahrscheinlich), erzwinge Plains auf 5,5
                if (!validSpawnFound) {
                    player.gridX = 5;
                    player.gridY = 5;
                    if(map[player.gridY][player.gridX].id === 'WATER' || map[player.gridY][player.gridX].object) {
                         const startTileTemplate = BIOMES.PLAINS;
                         const srcArray = Array.isArray(startTileTemplate.imageSrc) ? startTileTemplate.imageSrc : [startTileTemplate.imageSrc];
                         const variantIndex = Math.floor(Math.random() * srcArray.length);
                         map[player.gridY][player.gridX] = { ...startTileTemplate, variantIndex: variantIndex, object: null, walkable: true };
                    }
                }
                
                // Player Pixel Position initialisieren
                player.pixelX = player.gridX * ACTUAL_TILE_SIZE;
                player.pixelY = player.gridY * ACTUAL_TILE_SIZE;
                player.targetPixelX = player.pixelX;
                player.targetPixelY = player.pixelY;
            }

            // Input Handling
            const keys = {};

            // --- In-Game Action Menu ---
            const actionMenu = document.getElementById('action-menu');

            function showActionMenu(x, y, targetX, targetY) {
                const tile = map[targetY][targetX];
                if (!tile.object) return;

                actionMenu.innerHTML = '';
                
                if (tile.object.id === 'BUSH') {
                    // Harvest Button (Nur wenn harvestable)
                    if (tile.object.harvestable) {
                        const harvestBtn = document.createElement('button');
                        harvestBtn.className = 'action-btn';
                        harvestBtn.innerText = 'Harvest';
                        harvestBtn.onclick = () => {
                            tile.object.harvestable = false;
                            tile.object.regenMinutes = 720; // 12 Stunden = 720 Minuten
                            harvestedBushes.push({ x: targetX, y: targetY });
                            addItem('SWEETBERRY', 1);
                            console.log("Harvested Sweetberry! Regenerating in 12h.");
                            hideActionMenu();
                        };
                        actionMenu.appendChild(harvestBtn);
                    }

                    // Destroy Button
                    const destroyBtn = document.createElement('button');
                    destroyBtn.className = 'action-btn';
                    destroyBtn.innerText = 'Destroy';
                    destroyBtn.onclick = () => {
                        tile.object = null;
                        tile.walkable = true;
                        addItem('STICK', Math.floor(Math.random() * 3) + 1); // 1-3 Sticks
                        console.log("Destroyed Bush. Got Sticks.");
                        hideActionMenu();
                    };
                    actionMenu.appendChild(destroyBtn);
                } else if (tile.object.id === 'TREE') {
                    // Tree interaction
                    const chopBtn = document.createElement('button');
                    chopBtn.className = 'action-btn';
                    chopBtn.innerText = 'Chop';
                    chopBtn.onclick = () => {
                        // Bei Bäumen müssen wir alle Tiles des Baums entfernen
                        const mainX = tile.isMainTile ? targetX : tile.object.mainX;
                        const mainY = tile.isMainTile ? targetY : tile.object.mainY;
                        const treeW = OBJECTS.TREE.width;
                        const treeH = OBJECTS.TREE.height;

                        for(let dy=0; dy<treeH; dy++) {
                            for(let dx=0; dx<treeW; dx++) {
                                const ty = mainY + dy;
                                const tx = mainX + dx;
                                if (ty >= 0 && ty < MAP_HEIGHT && tx >= 0 && tx < MAP_WIDTH) {
                                    const t = map[ty][tx];
                                    if (t.object && (t.object.id === 'TREE')) {
                                        t.object = null;
                                        t.walkable = true;
                                    }
                                }
                            }
                        }
                        addItem('LOG', Math.floor(Math.random() * 2) + 1); // 1-2 Logs
                        console.log("Chopped Tree. Got Logs.");
                        hideActionMenu();
                    };
                    actionMenu.appendChild(chopBtn);
                }

                // Position berechnen (relativ zum Canvas/Screen)
                const screenX = Math.floor((targetX * ACTUAL_TILE_SIZE) - CAMERA.x);
                const screenY = Math.floor((targetY * ACTUAL_TILE_SIZE) - CAMERA.y);

                actionMenu.style.left = `${screenX + ACTUAL_TILE_SIZE + 10}px`;
                actionMenu.style.top = `${screenY}px`;
                actionMenu.style.display = 'flex';

                // Schließe Menü bei Klick irgendwo anders
                const closeActionMenu = (e) => {
                    if (!actionMenu.contains(e.target)) {
                        hideActionMenu();
                        document.removeEventListener('mousedown', closeActionMenu);
                    }
                };
                setTimeout(() => document.addEventListener('mousedown', closeActionMenu), 10);
            }

            function hideActionMenu() {
                actionMenu.style.display = 'none';
            }

            const handleKeyDown = (e) => { 
                if (player.inDialog) return; // Ignore movement keys during dialog
                if (e.key === 'Enter') {
                    // Verhindere, dass ein fokussierter Tab-Button per Enter geklickt wird
                    e.preventDefault();
                    const active = document.activeElement;
                    if (active && active.classList && active.classList.contains('tab-btn')) {
                        active.blur();
                    }
                    // Check interaction
                    const targetX = player.gridX + (player.direction === 2 ? 1 : player.direction === 1 ? -1 : 0);
                    const targetY = player.gridY + (player.direction === 0 ? 1 : player.direction === 3 ? -1 : 0);
                    
                    const entity = entities.find(e => 
                        Math.round(e.pixelX / ACTUAL_TILE_SIZE) === targetX && 
                        Math.round(e.pixelY / ACTUAL_TILE_SIZE) === targetY
                    );
                    
                    if (entity && entity.npc) {
                        openChat(entity);
                        keys[e.key] = false; // Prevent stuck key
                        return;
                    }
                    
                    if (targetX >= 0 && targetX < MAP_WIDTH && targetY >= 0 && targetY < MAP_HEIGHT) {
                        const t = map[targetY][targetX];
                        if (t.object && (t.object.id === 'BUSH' || t.object.id === 'TREE')) {
                            showActionMenu(e.clientX, e.clientY, targetX, targetY);
                            keys[e.key] = false;
                            return;
                        }
                    }
                }
                keys[e.key] = true; 
            };
            const handleKeyUp = (e) => { keys[e.key] = false; };

            window.addEventListener('keydown', handleKeyDown);
            window.addEventListener('keyup', handleKeyUp);

            function update() {
                if (player.inDialog) return; // Stop movement and updates during dialog

                // Bewegung verarbeiten
                if (player.isMoving) {
                    if (player.pixelX < player.targetPixelX) player.pixelX += MOVEMENT_SPEED;
                    if (player.pixelX > player.targetPixelX) player.pixelX -= MOVEMENT_SPEED;
                    if (player.pixelY < player.targetPixelY) player.pixelY += MOVEMENT_SPEED;
                    if (player.pixelY > player.targetPixelY) player.pixelY -= MOVEMENT_SPEED;

                    if (Math.abs(player.pixelX - player.targetPixelX) < MOVEMENT_SPEED && 
                        Math.abs(player.pixelY - player.targetPixelY) < MOVEMENT_SPEED) {
                        
                        player.pixelX = player.targetPixelX;
                        player.pixelY = player.targetPixelY;
                        player.isMoving = false;
                    }
                } else {
                    let dx = 0;
                    let dy = 0;
                    let newDirection = player.direction;

                    if (keys['ArrowUp'] || keys['w']) { dy = -1; newDirection = 3; } // Up
                    else if (keys['ArrowDown'] || keys['s']) { dy = 1; newDirection = 0; } // Down
                    else if (keys['ArrowLeft'] || keys['a']) { dx = -1; newDirection = 1; } // Left
                    else if (keys['ArrowRight'] || keys['d']) { dx = 1; newDirection = 2; } // Right

                    // Update direction immediately when key is pressed, even if blocked
                    if (dx !== 0 || dy !== 0) {
                        player.direction = newDirection;
                        
                        const newGridX = player.gridX + dx;
                        const newGridY = player.gridY + dy;

                        if (newGridX >= 0 && newGridX < MAP_WIDTH && newGridY >= 0 && newGridY < MAP_HEIGHT) {
                            const targetBiome = map[newGridY][newGridX];
                            
                            // Prüfen ob begehbar
                            // HINWEIS: Wir vertrauen hier darauf, dass generateMap() das 'walkable' Flag
                            // auf dem Tile korrekt gesetzt hat (auch für Objekte wie Bäume/Büsche).
                            if (targetBiome.walkable) {
                                // NEU: Check auf Entities (Pokemon)
                                // Player darf nicht durch Pokemon laufen
                                const entityCollision = entities.some(e => 
                                    Math.round(e.pixelX / ACTUAL_TILE_SIZE) === newGridX && 
                                    Math.round(e.pixelY / ACTUAL_TILE_SIZE) === newGridY
                                );

                                if (!entityCollision) {
                                    player.gridX = newGridX;
                                    player.gridY = newGridY;
                                    player.targetPixelX = newGridX * ACTUAL_TILE_SIZE;
                                    player.targetPixelY = newGridY * ACTUAL_TILE_SIZE;
                                    player.isMoving = true;
                                }
                            }
                        }
                    }
                }
                
                // Kamera Update
                const targetCamX = player.pixelX + (ACTUAL_TILE_SIZE / 2) - (canvas.width / 2);
                const targetCamY = player.pixelY + (ACTUAL_TILE_SIZE / 2) - (canvas.height / 2);
                
                CAMERA.x = targetCamX;
                CAMERA.y = targetCamY;

                CAMERA.x = Math.max(0, Math.min(CAMERA.x, (MAP_WIDTH * ACTUAL_TILE_SIZE) - canvas.width));
                CAMERA.y = Math.max(0, Math.min(CAMERA.y, (MAP_HEIGHT * ACTUAL_TILE_SIZE) - canvas.height));

                updateEntities();
            }

            function updateEntities() {
                entities.forEach(entity => {
                    // Entferne Updates für entfernte Entities (> ACTIVE_RANGE)
                    if (Math.abs(entity.gridX - player.gridX) > ACTIVE_RANGE || Math.abs(entity.gridY - player.gridY) > ACTIVE_RANGE) {
                        return;
                    }
                    // Hunger-Initialisierung
                    if (entity.npc && entity.npc.hunger === undefined) entity.npc.hunger = 100;

                    // Bewegung
                    if (entity.isMoving) {
                        const speed = 2; // Pixel pro Frame
                        let dx = entity.targetPixelX - entity.pixelX;
                        let dy = entity.targetPixelY - entity.pixelY;
                        
                        // Distanz prüfen
                        if (Math.abs(dx) <= speed && Math.abs(dy) <= speed) {
                            entity.pixelX = entity.targetPixelX;
                            entity.pixelY = entity.targetPixelY;
                            entity.isMoving = false;
                            entity.gridX = Math.round(entity.pixelX / ACTUAL_TILE_SIZE);
                            entity.gridY = Math.round(entity.pixelY / ACTUAL_TILE_SIZE);
                            
                            // Check ob Ziel erreicht (Busch zum Essen)
                            if (entity.targetFood) {
                                const { bushX, bushY } = entity.targetFood;
                                // Wir prüfen, ob wir direkt auf oder neben dem Busch sind
                                const dist = Math.abs(entity.gridX - bushX) + Math.abs(entity.gridY - bushY);
                                if (dist <= 1) {
                                    // Busch essen!
                                    const tile = map[bushY][bushX];
                                    if (tile.object && tile.object.id === 'BUSH' && tile.object.harvestable) {
                                        tile.object.harvestable = false;
                                        tile.object.regenMinutes = 720; // 12h Regeneration
                                        harvestedBushes.push({ x: bushX, y: bushY });
                                        entity.npc.hunger = 100; // Wieder voll
                                        entity.targetFood = null;
                                        console.log(`${entity.npc.name} ate a bush at ${bushX},${bushY}!`);
                                    } else {
                                        // Busch wurde schon gegessen/zerstört
                                        entity.targetFood = null;
                                    }
                                }
                            }

                            // Animation stoppen / Frame reset
                            entity.frame = 0; 
                        } else {
                            // Bewegen
                            if (Math.abs(dx) > 0) entity.pixelX += Math.sign(dx) * speed;
                            if (Math.abs(dy) > 0) entity.pixelY += Math.sign(dy) * speed;

                            // Animation
                            entity.animTimer++;
                            if (entity.animTimer > 10) { // Schneller animieren beim Laufen
                                entity.animTimer = 0;
                                entity.frame = (entity.frame + 1) % 4;
                            }
                        }
                    } else {
                        // AI: Hunger-Check (unter 20)
                        if (entity.npc && entity.npc.hunger < 20 && !entity.targetFood) {
                            // Nahrung suchen (Radius 15)
                            let nearestBush = null;
                            let minDist = 16;

                            for (let dy = -15; dy <= 15; dy++) {
                                for (let dx = -15; dx <= 15; dx++) {
                                    const tx = entity.gridX + dx;
                                    const ty = entity.gridY + dy;
                                    if (tx >= 0 && tx < MAP_WIDTH && ty >= 0 && ty < MAP_HEIGHT) {
                                        const tile = map[ty][tx];
                                        if (tile.object && tile.object.id === 'BUSH' && tile.object.harvestable) {
                                            const dist = Math.sqrt(dx*dx + dy*dy);
                                            if (dist < minDist) {
                                                // Suche ein begehbares Nachbartile für den Busch
                                                const neighbors = [
                                                    { x: tx, y: ty + 1 }, { x: tx - 1, y: ty },
                                                    { x: tx + 1, y: ty }, { x: tx, y: ty - 1 }
                                                ];
                                                const walkTile = neighbors.find(n => 
                                                    n.x >= 0 && n.x < MAP_WIDTH && n.y >= 0 && n.y < MAP_HEIGHT && 
                                                    map[n.y][n.x].walkable
                                                );

                                                if (walkTile) {
                                                    minDist = dist;
                                                    nearestBush = { bushX: tx, bushY: ty, targetX: walkTile.x, targetY: walkTile.y };
                                                }
                                            }
                                        }
                                    }
                                }
                            }

                            if (nearestBush) {
                                entity.targetFood = nearestBush;
                                console.log(`${entity.npc.name} is hungry and heading to bush neighbor at ${nearestBush.targetX},${nearestBush.targetY}`);
                            }
                        }

                        // Bewegung zu Ziel oder Zufällig
                        if (entity.targetFood) {
                            const { targetX, targetY } = entity.targetFood;
                            let dx = 0, dy = 0, dir = 0;

                            if (targetX < entity.gridX) { dx = -1; dir = 1; }
                            else if (targetX > entity.gridX) { dx = 1; dir = 2; }
                            else if (targetY < entity.gridY) { dy = -1; dir = 3; }
                            else if (targetY > entity.gridY) { dy = 1; dir = 0; }

                            if (dx !== 0 || dy !== 0) {
                                const newGridX = entity.gridX + dx;
                                const newGridY = entity.gridY + dy;
                                
                                // Kollisionsprüfung
                                const targetTile = map[newGridY][newGridX];
                                if (targetTile.walkable) {
                                    const entityCollision = entities.some(e => 
                                        e !== entity && 
                                        Math.round(e.pixelX / ACTUAL_TILE_SIZE) === newGridX && 
                                        Math.round(e.pixelY / ACTUAL_TILE_SIZE) === newGridY
                                    );
                                    if (!entityCollision) {
                                        entity.isMoving = true;
                                        entity.targetPixelX = newGridX * ACTUAL_TILE_SIZE;
                                        entity.targetPixelY = newGridY * ACTUAL_TILE_SIZE;
                                        entity.direction = dir;
                                        return;
                                    }
                                }
                                // Wenn Weg blockiert, Ziel kurzzeitig vergessen um Stau zu vermeiden
                                if (!entity.isMoving) entity.targetFood = null; 
                            } else {
                                // Wenn wir am Ziel-Tile angekommen sind, aber noch nicht gegessen haben 
                                // (weil die Distanz-Prüfung oben erst im nächsten Frame greift)
                                // Das ist okay, die Logik oben wird den Busch im nächsten Frame essen.
                            }
                        } else if (Math.random() < 0.01) { // 1% Chance pro Frame loszulaufen
                            const directions = [
                                { dx: 0, dy: 1, dir: 0 }, // Down
                                { dx: -1, dy: 0, dir: 1 }, // Left
                                { dx: 1, dy: 0, dir: 2 }, // Right
                                { dx: 0, dy: -1, dir: 3 } // Up
                            ];
                            
                            const move = directions[Math.floor(Math.random() * directions.length)];
                            const newGridX = entity.gridX + move.dx;
                            const newGridY = entity.gridY + move.dy;

                            // Check Bounds & Collision
                            if (newGridX >= 0 && newGridX < MAP_WIDTH && newGridY >= 0 && newGridY < MAP_HEIGHT) {
                                const targetTile = map[newGridY][newGridX];
                                if (targetTile.walkable) {
                                    // Check Player Collision
                                    const playerGridX = Math.round(player.pixelX / ACTUAL_TILE_SIZE);
                                    const playerGridY = Math.round(player.pixelY / ACTUAL_TILE_SIZE);
                                    
                                    // Check Entity Collision (nicht in andere Pokemon laufen)
                                    const entityCollision = entities.some(e => 
                                        e !== entity && // nicht sich selbst checken
                                        Math.round(e.pixelX / ACTUAL_TILE_SIZE) === newGridX && 
                                        Math.round(e.pixelY / ACTUAL_TILE_SIZE) === newGridY
                                    );

                                    if ((newGridX !== playerGridX || newGridY !== playerGridY) && !entityCollision) {
                                        entity.isMoving = true;
                                        entity.targetPixelX = newGridX * ACTUAL_TILE_SIZE;
                                        entity.targetPixelY = newGridY * ACTUAL_TILE_SIZE;
                                        entity.direction = move.dir;
                                    }
                                }
                            }
                        }
                    }
                });
            }

            function formatTime(mins) {
                const m = Math.floor(mins % 1440);
                const h = Math.floor(m / 60);
                const mm = Math.floor(m % 60);
                return String(h).padStart(2, '0') + ':' + String(mm).padStart(2, '0');
            }

            function getNightAlpha(mins) {
                const t = (mins % 1440) / 1440;
                const daylight = Math.max(0, 0.5 * (1 + Math.cos((t - 0.5) * 2 * Math.PI)));
                const darkness = 1 - daylight;
                return 0.5 * Math.pow(darkness, 1.2);
            }

            function draw() {
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Viewport Berechnung
                const cameraX = CAMERA.x;
                const cameraY = CAMERA.y;
                const startX = Math.floor(cameraX / ACTUAL_TILE_SIZE);
                const startY = Math.floor(cameraY / ACTUAL_TILE_SIZE);
                const endX = Math.min(MAP_WIDTH, startX + Math.ceil(canvas.width / ACTUAL_TILE_SIZE) + 1);
                const endY = Math.min(MAP_HEIGHT, startY + Math.ceil(canvas.height / ACTUAL_TILE_SIZE) + 1);
                
                // Sichtbereich auf 30x30 um den Spieler beschränken
                const visStartX = Math.max(0, Math.max(startX, player.gridX - ACTIVE_RANGE));
                const visEndX = Math.min(MAP_WIDTH, Math.min(endX, player.gridX + ACTIVE_RANGE + 1));
                const visStartY = Math.max(0, Math.max(startY, player.gridY - ACTIVE_RANGE));
                const visEndY = Math.min(MAP_HEIGHT, Math.min(endY, player.gridY + ACTIVE_RANGE + 1));

                // --- PASS 1: BODEN (Biomes) zeichnen ---
                for (let y = visStartY; y < visEndY; y++) {
                    for (let x = visStartX; x < visEndX; x++) {
                        if (y < 0 || y >= MAP_HEIGHT || x < 0 || x >= MAP_WIDTH) continue;

                        const tile = map[y][x];
                        const screenX = Math.floor((x * ACTUAL_TILE_SIZE) - cameraX);
                        const screenY = Math.floor((y * ACTUAL_TILE_SIZE) - cameraY);

                        // Optimierung: Nur zeichnen wenn im Bild
                        if (screenX + ACTUAL_TILE_SIZE < 0 || screenX > canvas.width || screenY + ACTUAL_TILE_SIZE < 0 || screenY > canvas.height) {
                           continue;
                        }

                        // Biom Textur
                        const biome = BIOMES[tile.id];
                        const variantIndex = tile.variantIndex || 0;
                        
                        // Versuche Textur aus Cache zu holen
                        let img = null;
                        if (images[tile.id] && images[tile.id][variantIndex]) {
                            img = images[tile.id][variantIndex];
                        }

                        if (img && img.complete && img.naturalWidth !== 0) {
                            try {
                                ctx.drawImage(img, screenX, screenY, ACTUAL_TILE_SIZE, ACTUAL_TILE_SIZE);
                            } catch (e) {
                                ctx.fillStyle = biome.color;
                                ctx.fillRect(screenX, screenY, ACTUAL_TILE_SIZE, ACTUAL_TILE_SIZE);
                            }
                        } else {
                            ctx.fillStyle = biome.color;
                            ctx.fillRect(screenX, screenY, ACTUAL_TILE_SIZE, ACTUAL_TILE_SIZE);
                        }
                    }
                }

                // --- PASS 2: OBJEKTE & SPIELER (Y-Sortiert) ---
                // Wir sammeln alle sichtbaren Objekte und den Spieler in einer Liste
                // und sortieren sie nach ihrer Y-Position (Unterkante des Sprites)
                
                const renderList = [];

                // 1. Spieler hinzufügen
                renderList.push({
                    type: 'player',
                    y: player.pixelY, // Oben
                    h: ACTUAL_TILE_SIZE,
                    sortY: player.pixelY + ACTUAL_TILE_SIZE // Unterkante
                });

                // 2. Entities (Pokemon) hinzufügen
                entities.forEach(entity => {
                    // Check ob im sichtbaren Bereich (grob)
                    const entX = entity.pixelX;
                    const entY = entity.pixelY;
                    const nearPlayer = Math.abs(entity.gridX - player.gridX) <= ACTIVE_RANGE && Math.abs(entity.gridY - player.gridY) <= ACTIVE_RANGE;
                    if (nearPlayer &&
                        entX > cameraX - 100 && entX < cameraX + canvas.width + 100 &&
                        entY > cameraY - 100 && entY < cameraY + canvas.height + 100) {
                        
                        renderList.push({
                            type: 'entity',
                            entity: entity,
                            y: entY,
                            h: ACTUAL_TILE_SIZE,
                            sortY: entY + ACTUAL_TILE_SIZE
                        });
                    }
                });

                // 3. Map Objekte im sichtbaren Bereich hinzufügen
                // Erweitere den Bereich leicht, damit große Objekte (Bäume) nicht zu früh ausgeblendet werden
                const objStartY = Math.max(0, visStartY - 5); 
                const objEndY = Math.min(MAP_HEIGHT, visEndY + 2);
                const objStartX = Math.max(0, visStartX - 2);
                const objEndX = Math.min(MAP_WIDTH, visEndX + 2);

                for (let y = objStartY; y < objEndY; y++) {
                    for (let x = objStartX; x < objEndX; x++) {
                        const tile = map[y][x];
                        if (tile.object && tile.isMainTile) {
                            // Nur Main Tiles werden gerendert (sie zeichnen das ganze Objekt)
                            let objW = ACTUAL_TILE_SIZE;
                            let objH = ACTUAL_TILE_SIZE;
                            let sortY = (y * ACTUAL_TILE_SIZE) + ACTUAL_TILE_SIZE; // Default Single Tile

                            if (tile.object.id === 'TREE') {
                                objW = tile.object.width * ACTUAL_TILE_SIZE;
                                objH = tile.object.height * ACTUAL_TILE_SIZE;
                                sortY = (y * ACTUAL_TILE_SIZE) + objH; // Unterkante des Baums
                            }

                            renderList.push({
                                type: 'object',
                                tile: tile,
                                gridX: x,
                                gridY: y,
                                w: objW,
                                h: objH,
                                sortY: sortY
                            });
                        } else if (tile.object && (tile.object.id === 'BUSH' || tile.object.id === 'CAMPFIRE')) {
                             // Busch & Campfire sind 1x1
                             if (!tile.object.isPart) {
                                renderList.push({
                                    type: 'object',
                                    tile: tile,
                                    gridX: x,
                                    gridY: y,
                                    w: ACTUAL_TILE_SIZE,
                                    h: ACTUAL_TILE_SIZE,
                                    sortY: (y * ACTUAL_TILE_SIZE) + ACTUAL_TILE_SIZE
                                });
                             }
                        }
                    }
                }

                // --- PASS 3: BUILD PREVIEW (Ghost) ---
                if (currentBuildId) {
                    const mouseTileX = Math.floor((mouseX + cameraX) / ACTUAL_TILE_SIZE);
                    const mouseTileY = Math.floor((mouseY + cameraY) / ACTUAL_TILE_SIZE);
                    
                    if (mouseTileX >= 0 && mouseTileX < MAP_WIDTH && mouseTileY >= 0 && mouseTileY < MAP_HEIGHT) {
                        const b = BUILDINGS[currentBuildId];
                        const screenX = Math.floor((mouseTileX * ACTUAL_TILE_SIZE) - cameraX);
                        const screenY = Math.floor((mouseTileY * ACTUAL_TILE_SIZE) - cameraY);
                        
                        const tile = map[mouseTileY][mouseTileX];
                        const canPlace = tile.walkable && !tile.object;
                        
                        ctx.save();
                        ctx.globalAlpha = 0.5;
                        
                        let img = null;
                        if (images[b.id] && images[b.id][0]) {
                            img = images[b.id][0];
                        }
                        
                        if (img && img.complete) {
                            ctx.drawImage(img, screenX, screenY, ACTUAL_TILE_SIZE, ACTUAL_TILE_SIZE);
                        } else {
                            ctx.fillStyle = canPlace ? 'rgba(0, 255, 0, 0.5)' : 'rgba(255, 0, 0, 0.5)';
                            ctx.fillRect(screenX, screenY, ACTUAL_TILE_SIZE, ACTUAL_TILE_SIZE);
                        }
                        
                        // Rahmen
                        ctx.strokeStyle = canPlace ? '#0f0' : '#f00';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(screenX, screenY, ACTUAL_TILE_SIZE, ACTUAL_TILE_SIZE);
                        
                        ctx.restore();
                    }
                }

                // Sortieren nach sortY (Painter's Algorithm)
                renderList.sort((a, b) => a.sortY - b.sortY);

                // Rendern
                for (const item of renderList) {
                    if (item.type === 'player') {
                        // Spieler zeichnen
                        const screenX = Math.floor(player.pixelX - cameraX);
                        const screenY = Math.floor(player.pixelY - cameraY);
                        
                        // Einfacher Spieler (Rot)
                        ctx.fillStyle = '#ff0000';
                        ctx.fillRect(screenX, screenY, ACTUAL_TILE_SIZE, ACTUAL_TILE_SIZE);
                        
                        // Augen (optional) - Dynamisch basierend auf Richtung
                        ctx.fillStyle = '#000';
                        
                        // Default Down (0)
                        let eyeLX = screenX + 8;
                        let eyeLY = screenY + 8;
                        let eyeRX = screenX + 20;
                        let eyeRY = screenY + 8;
                        
                        if (player.direction === 1) { // Left
                            eyeLX = screenX + 4;
                            eyeRX = screenX + 4;
                        } else if (player.direction === 2) { // Right
                            eyeLX = screenX + 24;
                            eyeRX = screenX + 24;
                        } else if (player.direction === 3) { // Up
                            // Keine Augen oder höher? Machen wir sie weg für "Rückenansicht"
                            eyeLX = -100; 
                            eyeRX = -100;
                        }

                        if (player.direction !== 3) {
                            ctx.fillRect(eyeLX, eyeLY, 4, 4);
                            ctx.fillRect(eyeRX, eyeRY, 4, 4);
                        }

                    } else if (item.type === 'entity') {
                        // Pokemon zeichnen
                        const entity = item.entity;
                        const screenX = Math.floor(entity.pixelX - cameraX);
                        const screenY = Math.floor(entity.pixelY - cameraY);
                        
                        // Versuchen das MOVE Sprite zu laden
                        const pokeId = entity.data.id;
                        const moveImgs = images[pokeId + '_MOVE'];
                        const img = moveImgs ? moveImgs[0] : null;

                        if (img && img.complete && img.naturalWidth !== 0) {
                            // Sprite Sheet Logic
                            // Dynamische Frame-Größe basierend auf Bildgröße (4x4 Grid)
                            const frameW = img.naturalWidth / 4;
                            const frameH = img.naturalHeight / 4;
                            
                            const srcX = entity.frame * frameW; // Animation frame (0-3)
                            const srcY = entity.direction * frameH; // Direction row
                            
                            // Pixel-Art Scaling erzwingen
                            ctx.imageSmoothingEnabled = false;
                            
                            // Zeichnen
                            // Zielgröße: ACTUAL_TILE_SIZE * Scale (da Sprite viel Padding hat)
                            // User Feedback: "ist zu klein" -> Wir skalieren es größer (z.B. 2x), damit es das Tile füllt.
                            const drawScale = 2.0;
                            const destW = ACTUAL_TILE_SIZE * drawScale;
                            const destH = ACTUAL_TILE_SIZE * drawScale;

                            // Zentriert am Boden des Tiles ausrichten
                            const destX = screenX + (ACTUAL_TILE_SIZE - destW) / 2;
                            const destY = screenY + (ACTUAL_TILE_SIZE - destH);

                            ctx.drawImage(img, srcX, srcY, frameW, frameH, destX, destY, destW, destH);

                        } else {
                            // Fallback: Lila Kreis
                            ctx.fillStyle = "#9932CC";
                            ctx.beginPath();
                            ctx.arc(screenX + ACTUAL_TILE_SIZE/2, screenY + ACTUAL_TILE_SIZE/2, ACTUAL_TILE_SIZE/3, 0, Math.PI*2);
                            ctx.fill();
                        }

                    } else if (item.type === 'object') {
                        const tile = item.tile;
                        const screenX = Math.floor((item.gridX * ACTUAL_TILE_SIZE) - cameraX);
                        const screenY = Math.floor((item.gridY * ACTUAL_TILE_SIZE) - cameraY);

                        if (tile.object.id === 'BUSH') {
                            const objImages = images[tile.object.id];
                            const idx = tile.object.harvestable ? 1 : 0;
                            const objImg = objImages ? objImages[idx] : null;
                            if (objImg && objImg.complete && objImg.naturalWidth !== 0) {
                                ctx.drawImage(objImg, screenX, screenY, ACTUAL_TILE_SIZE, ACTUAL_TILE_SIZE);
                            } else {
                                // Fallback Busch
                                ctx.fillStyle = "#00aa00";
                                ctx.beginPath();
                                ctx.arc(screenX + ACTUAL_TILE_SIZE/2, screenY + ACTUAL_TILE_SIZE/2, ACTUAL_TILE_SIZE/3, 0, Math.PI*2);
                                ctx.fill();
                            }
                        } else if (tile.object.id === 'TREE') {
                             const objImages = images[tile.object.id];
                             const objImg = objImages ? objImages[0] : null;
                             
                             if (objImg && objImg.complete && objImg.naturalWidth !== 0) {
                                 // Baum zeichnen
                                 ctx.drawImage(objImg, screenX, screenY, item.w, item.h); 
                             } else {
                                 // Fallback Baum (Rechteck)
                                 ctx.fillStyle = "#006600";
                                 ctx.fillRect(screenX, screenY, item.w, item.h);
                             }
                        } else if (tile.object.id === 'CAMPFIRE') {
                             const objImages = images[tile.object.id];
                             const objImg = objImages ? objImages[0] : null;
                             if (objImg && objImg.complete && objImg.naturalWidth !== 0) {
                                 ctx.drawImage(objImg, screenX, screenY, ACTUAL_TILE_SIZE, ACTUAL_TILE_SIZE);
                             } else {
                                 // Fallback Campfire (Orange)
                                 ctx.fillStyle = "#ff6600";
                                 ctx.beginPath();
                                 ctx.arc(screenX + ACTUAL_TILE_SIZE/2, screenY + ACTUAL_TILE_SIZE/2, ACTUAL_TILE_SIZE/4, 0, Math.PI*2);
                                 ctx.fill();
                             }
                        }
                    }
                }
                
                const nightAlpha = getNightAlpha(gameMinutes);
                if (nightAlpha > 0) {
                    // Erstelle ein temporäres Canvas für das Licht-Masking
                    const lightCanvas = document.createElement('canvas');
                    lightCanvas.width = canvas.width;
                    lightCanvas.height = canvas.height;
                    const lCtx = lightCanvas.getContext('2d');

                    // 1. Fülle alles mit der Nachtfarbe
                    lCtx.fillStyle = `rgba(0,16,51,${nightAlpha})`;
                    lCtx.fillRect(0, 0, canvas.width, canvas.height);

                    // 2. "Löcher" für Lichtquellen schneiden
                    lCtx.globalCompositeOperation = 'destination-out';

                    lightSources.forEach(light => {
                        const screenX = Math.floor((light.x * ACTUAL_TILE_SIZE) - cameraX) + ACTUAL_TILE_SIZE / 2;
                        const screenY = Math.floor((light.y * ACTUAL_TILE_SIZE) - cameraY) + ACTUAL_TILE_SIZE / 2;
                        
                        // Check ob im sichtbaren Bereich
                        if (screenX > -200 && screenX < canvas.width + 200 && screenY > -200 && screenY < canvas.height + 200) {
                            const grad = lCtx.createRadialGradient(
                                screenX, screenY, 0, 
                                screenX, screenY, light.radius * ACTUAL_TILE_SIZE
                            );
                            grad.addColorStop(0, 'rgba(255, 255, 255, 1.0)'); // Volle Helligkeit im Zentrum
                            grad.addColorStop(1, 'rgba(255, 255, 255, 0.0)'); // Auslaufend zum Rand
                            
                            lCtx.fillStyle = grad;
                            lCtx.beginPath();
                            lCtx.arc(screenX, screenY, light.radius * ACTUAL_TILE_SIZE, 0, Math.PI * 2);
                            lCtx.fill();
                        }
                    });

                    // 3. Die fertige Lichtmaske auf das Hauptcanvas zeichnen
                    ctx.drawImage(lightCanvas, 0, 0);
                }
                
                // Debug Info
                const debugEl = document.getElementById('debug');
                if (debugEl) {
                    const currentBiome = map[player.gridY][player.gridX];
                    const variant = currentBiome.variantIndex !== undefined ? currentBiome.variantIndex : 0;
                    
                    const climate = getHarmonizedClimate(player.gridX, player.gridY);
                    const dayNightIcon = climate.isNight ? '🌙' : '☀️';
                    const warmthIcon = climate.isWarm ? '🔥 ' : '';
                    
                    let debugText = `Pos: ${player.gridX}, ${player.gridY} | Biom: ${currentBiome.name} (Var: ${variant + 1}) | Klima: ${warmthIcon}${dayNightIcon} ${climate.weather}, ${climate.temp}°C (${climate.humidity}%) | Time: ${formatTime(gameMinutes)} | Hunger: ${player.hunger}% | Thirst: ${player.thirst}%`;
                    
                    // Check entity at player pos
                    const entityAtPlayer = entities.find(e => 
                        Math.round(e.pixelX / ACTUAL_TILE_SIZE) === player.gridX && 
                        Math.round(e.pixelY / ACTUAL_TILE_SIZE) === player.gridY
                    );

                    if (entityAtPlayer && entityAtPlayer.npc) {
                        debugText += `\nNPC: ${entityAtPlayer.npc.name} | Age: ${entityAtPlayer.npc.age} | Hunger: ${entityAtPlayer.npc.hunger}% | Traits: ${entityAtPlayer.npc.traits.join(', ')}`;
                    }

                    debugEl.innerText = debugText;
                }
            }
            
            // Kleiner Helper damit Console nicht geflutet wird
            console.warnOnce = function(msg, e) {
                if(!console.warnOnce.logged) {
                    console.warn(msg, e);
                    console.warnOnce.logged = true;
                }
            }

            function updateWeather(minutesDelta) {
                weatherTimer -= minutesDelta;
                if (weatherTimer <= 0) {
                    // Wähle neues Wetter (RimWorld-ähnliche Übergänge)
                    const oldWeather = currentGlobalWeather;
                    const rand = Math.random();
                    
                    if (oldWeather === 'CLEAR') {
                        currentGlobalWeather = rand < 0.7 ? 'CLOUDY' : 'CLEAR';
                    } else if (oldWeather === 'CLOUDY') {
                        currentGlobalWeather = rand < 0.4 ? 'RAIN' : (rand < 0.7 ? 'CLEAR' : 'CLOUDY');
                    } else if (oldWeather === 'RAIN') {
                        currentGlobalWeather = rand < 0.3 ? 'STORM' : (rand < 0.8 ? 'CLOUDY' : 'RAIN');
                    } else if (oldWeather === 'STORM') {
                        currentGlobalWeather = rand < 0.6 ? 'RAIN' : 'STORM';
                    }
                    
                    weatherTimer = 120 + Math.random() * 240; // 2-6 Stunden
                    console.log(`Global weather changed to ${currentGlobalWeather}`);
                }
            }

            function getHarmonizedClimate(gridX, gridY) {
                let totalTemp = 0;
                let totalHumidity = 0;
                let count = 0;
                
                // 3x3 Umgebung für Interpolation
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        const nx = gridX + dx;
                        const ny = gridY + dy;
                        if (nx >= 0 && nx < MAP_WIDTH && ny >= 0 && ny < MAP_HEIGHT) {
                            const biome = map[ny][nx];
                            const clima = BIOMES[biome.id].clima[currentGlobalWeather];
                            totalTemp += clima.temp;
                            totalHumidity += clima.humidity;
                            count++;
                        }
                    }
                }
                
                const avgTemp = totalTemp / count;
                const avgHumidity = totalHumidity / count;
                
                // Tag/Nacht Offset (In der Nacht ist es kälter)
                const timeOfDay = (gameMinutes % 1440) / 1440;
                // Sinuskurve: Maximum um 14:00 Uhr, Minimum um 02:00 Uhr
                // Wir verschieben die Phase leicht für realistischere Kurve
                const tempOffset = Math.sin((timeOfDay - 0.33) * 2 * Math.PI) * 15; // -15 bis +15 Grad
                
                const currentBiome = map[gridY][gridX];
                const localWeather = BIOMES[currentBiome.id].clima[currentGlobalWeather].weather;
                
                // Nacht-Zusatzeffekt: -5 Grad zusätzlich zwischen 22:00 und 05:00
                const isNight = (gameMinutes < 300 || gameMinutes > 1320);
                const nightChill = isNight ? -5 : 0;
                
                // Campfire Wärme-Effekt (+5 Grad in der Nähe)
                let campfireBonus = 0;
                const nearCampfire = lightSources.some(light => {
                    const dist = Math.sqrt(Math.pow(light.x - gridX, 2) + Math.pow(light.y - gridY, 2));
                    return dist <= 2.5; // Gleicher Radius wie das Licht
                });
                if (nearCampfire) campfireBonus = 5;
                
                return {
                    temp: Math.round(avgTemp + tempOffset + nightChill + campfireBonus),
                    humidity: Math.round(avgHumidity),
                    weather: localWeather,
                    isNight: isNight,
                    isWarm: campfireBonus > 0
                };
            }

            function gameLoop() {
                if(!gameRunning) return;
                const now = performance.now();
                const dt = (now - lastFrameTime) / 1000;
                lastFrameTime = now;
                const minutesDelta = dt * MINUTES_PER_SECOND;
                gameMinutes = (gameMinutes + minutesDelta) % 1440;
                
                updateWeather(minutesDelta);

                // NPC Hunger Update
                entities.forEach(entity => {
                    if (entity.npc) {
                        entity.npc.hunger = (entity.npc.hunger || 100) - (HUNGER_TICK_AMOUNT * 0.1);
                        if (entity.npc.hunger < 0) entity.npc.hunger = 0;
                    }
                });

                // Busch-Regeneration
                if (harvestedBushes.length > 0) {
                    for (let i = harvestedBushes.length - 1; i >= 0; i--) {
                        const { x, y } = harvestedBushes[i];
                        const tile = map[y][x];
                        if (tile.object && tile.object.id === 'BUSH') {
                            tile.object.regenMinutes -= minutesDelta;
                            if (tile.object.regenMinutes <= 0) {
                                tile.object.harvestable = true;
                                harvestedBushes.splice(i, 1);
                                console.log(`Bush at ${x},${y} has regrown!`);
                            }
                        } else {
                            // Busch wurde zerstört
                            harvestedBushes.splice(i, 1);
                        }
                    }
                }

                needsAccum += minutesDelta;
                while (needsAccum >= HUNGER_TICK_MINUTES) {
                    needsAccum -= HUNGER_TICK_MINUTES;
                    
                    const climate = getHarmonizedClimate(player.gridX, player.gridY);
                    const thirstMultiplier = climate.temp > 30 ? 2 : (climate.temp < 5 ? 1.5 : 1);
                    
                    player.hunger = Math.max(0, player.hunger - HUNGER_TICK_AMOUNT);
                    player.thirst = Math.max(0, player.thirst - (THIRST_TICK_AMOUNT * thirstMultiplier));
                    entities.forEach(e => {
                        if (e.npc) {
                            e.npc.hunger = Math.max(0, (e.npc.hunger || 0) - HUNGER_TICK_AMOUNT);
                            e.npc.thirst = Math.max(0, (e.npc.thirst || 0) - THIRST_TICK_AMOUNT);
                        }
                    });
                }
                update();
                draw();
                animationFrameId = requestAnimationFrame(gameLoop);
            }

            // Initiale Menü Anzeige
            mainMenu.classList.remove('hidden');
            
            // Bilder vorladen im Hintergrund
            loadImages();
            
        })(); // Ende der IIFE
    </script>
</body>
</html>





